{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Ninja - Fast Django REST Framework Django Ninja is a web framework for building APIs with Django and Python 3.6+ type hints. Django Ninja\u662f\u4e00\u4e2a\u57fa\u4e8eDjango\u548cPython 3.6+\u7684\u7c7b\u578b\u63d0\u793aAPI\u6784\u5efa\u800c\u6210\u7684web\u6846\u67b6 Key features: Easy : Designed to be easy to use and intuitive. FAST execution : Very high performance thanks to Pydantic and async support . Fast to code : Type hints and automatic docs lets you focus only on business logic. Standards-based : Based on the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . Django friendly : (obviously) has good integration with the Django core and ORM. Production ready : Used by multiple companies on live projects (If you use Django Ninja and would like to publish your feedback, please email ppr.vitaly@gmail.com). Benchmarks : Installation pip install django-ninja Quick Example Start a new Django project (or use an existing one) django-admin startproject apidemo in urls.py from django.contrib import admin from django.urls import path from ninja import NinjaAPI api = NinjaAPI () @api . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ] Now, run it as usual: ./manage.py runserver Note: You don't have to add Django Ninja to your installed apps for it to work. Check it Open your browser at http://127.0.0.1:8000/api/add?a=1&b=2 You will see the JSON response as: { \"result\" : 3 } Now you've just created an API that: receives an HTTP GET request at /api/add takes, validates and type-casts GET parameters a and b decodes the result to JSON generates an OpenAPI schema for defined operation Interactive API docs Now go to http://127.0.0.1:8000/api/docs You will see the automatic, interactive API documentation (provided by the OpenAPI / Swagger UI ): Recap In summary, you declare the types of parameters, body, etc. once only , as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python 3.6+ . For example, for an int : a : int or, for a more complex Item model: class Item ( Schema ): foo : str bar : float def operation ( a : Item ): ... ... and with that single declaration you get: Editor support, including: Completion Type checks Validation of data: Automatic and clear errors when the data is invalid Validation, even for deeply nested JSON objects Conversion of input data coming from the network, to Python data and types, and reading from: JSON Path parameters Query parameters Cookies Headers Forms Files Automatic, interactive API documentation This project was heavily inspired by FastAPI (developed by Sebasti\u00e1n Ram\u00edrez )","title":"Intro"},{"location":"#django-ninja-fast-django-rest-framework","text":"Django Ninja is a web framework for building APIs with Django and Python 3.6+ type hints. Django Ninja\u662f\u4e00\u4e2a\u57fa\u4e8eDjango\u548cPython 3.6+\u7684\u7c7b\u578b\u63d0\u793aAPI\u6784\u5efa\u800c\u6210\u7684web\u6846\u67b6 Key features: Easy : Designed to be easy to use and intuitive. FAST execution : Very high performance thanks to Pydantic and async support . Fast to code : Type hints and automatic docs lets you focus only on business logic. Standards-based : Based on the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . Django friendly : (obviously) has good integration with the Django core and ORM. Production ready : Used by multiple companies on live projects (If you use Django Ninja and would like to publish your feedback, please email ppr.vitaly@gmail.com). Benchmarks :","title":"Django Ninja - Fast Django REST Framework"},{"location":"#installation","text":"pip install django-ninja","title":"Installation"},{"location":"#quick-example","text":"Start a new Django project (or use an existing one) django-admin startproject apidemo in urls.py from django.contrib import admin from django.urls import path from ninja import NinjaAPI api = NinjaAPI () @api . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ] Now, run it as usual: ./manage.py runserver Note: You don't have to add Django Ninja to your installed apps for it to work.","title":"Quick Example"},{"location":"#check-it","text":"Open your browser at http://127.0.0.1:8000/api/add?a=1&b=2 You will see the JSON response as: { \"result\" : 3 } Now you've just created an API that: receives an HTTP GET request at /api/add takes, validates and type-casts GET parameters a and b decodes the result to JSON generates an OpenAPI schema for defined operation","title":"Check it"},{"location":"#interactive-api-docs","text":"Now go to http://127.0.0.1:8000/api/docs You will see the automatic, interactive API documentation (provided by the OpenAPI / Swagger UI ):","title":"Interactive API docs"},{"location":"#recap","text":"In summary, you declare the types of parameters, body, etc. once only , as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard Python 3.6+ . For example, for an int : a : int or, for a more complex Item model: class Item ( Schema ): foo : str bar : float def operation ( a : Item ): ... ... and with that single declaration you get: Editor support, including: Completion Type checks Validation of data: Automatic and clear errors when the data is invalid Validation, even for deeply nested JSON objects Conversion of input data coming from the network, to Python data and types, and reading from: JSON Path parameters Query parameters Cookies Headers Forms Files Automatic, interactive API documentation This project was heavily inspired by FastAPI (developed by Sebasti\u00e1n Ram\u00edrez )","title":"Recap"},{"location":"async-support/","text":"Intro Since version 3.1 , Django comes with async views support . This allows you run efficient concurrent views that are network and/or IO bound. pip install Django>=3.1 django-ninja Async views work more efficiently when it comes to: calling external APIs over the network executing/waiting for database queries reading/writing from/to disk drives Django Ninja takes full advantage of async views and makes it very easy to work with them. Quick example Code Let's take an example. We have an API operation that does some work (currently just sleeps for provided number of seconds) and returns a word: import time @api . get ( \"/say-after\" ) def say_after ( request , delay : int , word : str ): time . sleep ( delay ) return { \"saying\" : word } To make this code asynchronous, all you have to do is add the async keyword to a function (and use async aware libraries for work processing - in our case we will replace the stdlib sleep with asyncio.sleep ): import asyncio @api . get ( \"/say-after\" ) async def say_after ( request , delay : int , word : str ): await asyncio . sleep ( delay ) return { \"saying\" : word } Run To run this code you need an ASGI server like Uvicorn or Daphne . Let's use Uvicorn for, example: To install Uvicorn, use: pip install uvicorn Then start the server: uvicorn your_project.asgi:application --reload Note: replace your_project with your project package name --reload flag used to automatically reload server if you do any changes to the code (do not use on production) Note You can run async views with manage.py runserver , but it does not work well with some libraries, so at this time (July 2020) it is recommended to use ASGI servers like Uvicorn or Daphne. Test Go to your browser and open http://127.0.0.1:8000/api/say-after?delay=3&word=hello ( delay=3 ) After a 3-second wait you should see the \"hello\" message. Now let's flood this operation with 100 parallel requests : ab -c 100 -n 100 \"http://127.0.0.1:8000/api/say-after?delay=3&word=hello\" which will result in something like this: Connection Times (ms) min mean[+/-sd] median max Connect: 0 1 1.1 1 4 Processing: 3008 3063 16.2 3069 3082 Waiting: 3008 3062 15.7 3068 3079 Total: 3008 3065 16.3 3070 3083 Percentage of the requests served within a certain time (ms) 50% 3070 66% 3072 75% 3075 80% 3076 90% 3081 95% 3082 98% 3083 99% 3083 100% 3083 (longest request) Based on the numbers, our service was able to handle each of the 100 concurrent requests with just a little overhead. To achieve the same concurrency with WSGI and sync operations you would need to spin up about 10 workers with 10 threads each! Mixing sync and async operations Keep in mind that you can use both sync and async operations in your project, and Django Ninja will route it automatically: @api . get ( \"/say-sync\" ) def say_after_sync ( request , delay : int , word : str ): time . sleep ( delay ) return { \"saying\" : word } @api . get ( \"/say-async\" ) async def say_after_async ( request , delay : int , word : str ): await asyncio . sleep ( delay ) return { \"saying\" : word } Elasticsearch example Let's take a real world use case. For this example, let's use the latest version of Elasticsearch that now comes with async support: pip install elasticsearch>=7.8.0 And now instead of the Elasticsearch class, use the AsyncElasticsearch class and await the results: from ninja import NinjaAPI from elasticsearch import AsyncElasticsearch api = NinjaAPI () es = AsyncElasticsearch () @api . get ( \"/search\" ) async def search ( request , q : str ): resp = await es . search ( index = \"documents\" , body = { \"query\" : { \"query_string\" : { \"query\" : q }}}, size = 20 , ) return resp [ \"hits\" ] Using ORM Currently, (July 2020) certain key parts of Django are not able to operate safely in an async environment, as they have global state that is not coroutine-aware. These parts of Django are classified as \u201casync-unsafe\u201d, and are protected from execution in an async environment. The ORM is the main example, but there are other parts that are also protected in this way. Learn more about async safety here: https://docs.djangoproject.com/en/3.1/topics/async/#async-safety So, if you do this: @api . get ( \"/blog/ {post_id} \" ) async def search ( request , post_id : int ): blog = Blog . objects . get ( pk = post_id ) ... it throws an error. Until the async ORM is implemented, you can use the sync_to_async() adapter: from asgiref.sync import sync_to_async @sync_to_async def get_blog ( post_id ): return Blog . objects . get ( pk = post_id ) @api . get ( \"/blog/ {post_id} \" ) async def search ( request , post_id : int ): blog = await get_blog ( post_id ) ... or even shorter: @api . get ( \"/blog/ {post_id} \" ) async def search ( request , post_id : int ): blog = await sync_to_async ( Blog . objects . get )( pk = post_id ) ... There is a common GOTCHA : Django queryset's are lazily evaluated (database query happens only when you start iterating), so this will not work: all_blogs = await sync_to_async ( Blog . objects . all )() # it will throw an error later when you try to iterate over all_blogs ... Instead, use evaluation (with list ): all_blogs = await sync_to_async ( list )( Blog . objects . all ()) ...","title":"Async support"},{"location":"async-support/#intro","text":"Since version 3.1 , Django comes with async views support . This allows you run efficient concurrent views that are network and/or IO bound. pip install Django>=3.1 django-ninja Async views work more efficiently when it comes to: calling external APIs over the network executing/waiting for database queries reading/writing from/to disk drives Django Ninja takes full advantage of async views and makes it very easy to work with them.","title":"Intro"},{"location":"async-support/#quick-example","text":"","title":"Quick example"},{"location":"async-support/#code","text":"Let's take an example. We have an API operation that does some work (currently just sleeps for provided number of seconds) and returns a word: import time @api . get ( \"/say-after\" ) def say_after ( request , delay : int , word : str ): time . sleep ( delay ) return { \"saying\" : word } To make this code asynchronous, all you have to do is add the async keyword to a function (and use async aware libraries for work processing - in our case we will replace the stdlib sleep with asyncio.sleep ): import asyncio @api . get ( \"/say-after\" ) async def say_after ( request , delay : int , word : str ): await asyncio . sleep ( delay ) return { \"saying\" : word }","title":"Code"},{"location":"async-support/#run","text":"To run this code you need an ASGI server like Uvicorn or Daphne . Let's use Uvicorn for, example: To install Uvicorn, use: pip install uvicorn Then start the server: uvicorn your_project.asgi:application --reload Note: replace your_project with your project package name --reload flag used to automatically reload server if you do any changes to the code (do not use on production) Note You can run async views with manage.py runserver , but it does not work well with some libraries, so at this time (July 2020) it is recommended to use ASGI servers like Uvicorn or Daphne.","title":"Run"},{"location":"async-support/#test","text":"Go to your browser and open http://127.0.0.1:8000/api/say-after?delay=3&word=hello ( delay=3 ) After a 3-second wait you should see the \"hello\" message. Now let's flood this operation with 100 parallel requests : ab -c 100 -n 100 \"http://127.0.0.1:8000/api/say-after?delay=3&word=hello\" which will result in something like this: Connection Times (ms) min mean[+/-sd] median max Connect: 0 1 1.1 1 4 Processing: 3008 3063 16.2 3069 3082 Waiting: 3008 3062 15.7 3068 3079 Total: 3008 3065 16.3 3070 3083 Percentage of the requests served within a certain time (ms) 50% 3070 66% 3072 75% 3075 80% 3076 90% 3081 95% 3082 98% 3083 99% 3083 100% 3083 (longest request) Based on the numbers, our service was able to handle each of the 100 concurrent requests with just a little overhead. To achieve the same concurrency with WSGI and sync operations you would need to spin up about 10 workers with 10 threads each!","title":"Test"},{"location":"async-support/#mixing-sync-and-async-operations","text":"Keep in mind that you can use both sync and async operations in your project, and Django Ninja will route it automatically: @api . get ( \"/say-sync\" ) def say_after_sync ( request , delay : int , word : str ): time . sleep ( delay ) return { \"saying\" : word } @api . get ( \"/say-async\" ) async def say_after_async ( request , delay : int , word : str ): await asyncio . sleep ( delay ) return { \"saying\" : word }","title":"Mixing sync and async operations"},{"location":"async-support/#elasticsearch-example","text":"Let's take a real world use case. For this example, let's use the latest version of Elasticsearch that now comes with async support: pip install elasticsearch>=7.8.0 And now instead of the Elasticsearch class, use the AsyncElasticsearch class and await the results: from ninja import NinjaAPI from elasticsearch import AsyncElasticsearch api = NinjaAPI () es = AsyncElasticsearch () @api . get ( \"/search\" ) async def search ( request , q : str ): resp = await es . search ( index = \"documents\" , body = { \"query\" : { \"query_string\" : { \"query\" : q }}}, size = 20 , ) return resp [ \"hits\" ]","title":"Elasticsearch example"},{"location":"async-support/#using-orm","text":"Currently, (July 2020) certain key parts of Django are not able to operate safely in an async environment, as they have global state that is not coroutine-aware. These parts of Django are classified as \u201casync-unsafe\u201d, and are protected from execution in an async environment. The ORM is the main example, but there are other parts that are also protected in this way. Learn more about async safety here: https://docs.djangoproject.com/en/3.1/topics/async/#async-safety So, if you do this: @api . get ( \"/blog/ {post_id} \" ) async def search ( request , post_id : int ): blog = Blog . objects . get ( pk = post_id ) ... it throws an error. Until the async ORM is implemented, you can use the sync_to_async() adapter: from asgiref.sync import sync_to_async @sync_to_async def get_blog ( post_id ): return Blog . objects . get ( pk = post_id ) @api . get ( \"/blog/ {post_id} \" ) async def search ( request , post_id : int ): blog = await get_blog ( post_id ) ... or even shorter: @api . get ( \"/blog/ {post_id} \" ) async def search ( request , post_id : int ): blog = await sync_to_async ( Blog . objects . get )( pk = post_id ) ... There is a common GOTCHA : Django queryset's are lazily evaluated (database query happens only when you start iterating), so this will not work: all_blogs = await sync_to_async ( Blog . objects . all )() # it will throw an error later when you try to iterate over all_blogs ... Instead, use evaluation (with list ): all_blogs = await sync_to_async ( list )( Blog . objects . all ()) ...","title":"Using ORM"},{"location":"help/","text":"Help / Get Help Do you like Django Ninja? If you like this project, there is a tiny thing you can do to let us know that we're moving in the right direction. Simply give django-ninja a star on github or share this URL on social media: https://django-ninja.rest-framework.com Do you want to help us? Pull requests are always welcome. You can inspect our docs for typos and spelling mistakes, and create pull requests or open an issue . If you have any suggestions to improve Django Ninja , please create them as issues on GitHub. Do you need help? Do not hesitate. Go to GitHub issues and describe your question or problem. We'll attempt to address them quickly. Join the chat at our Discord server. Code-on the webdesign and web development company gives commercial consulting for Django-Ninja. If you are looking for support please contact Code-on and we will be in touch with you soon.","title":"Help / Get Help"},{"location":"help/#help-get-help","text":"","title":"Help / Get Help"},{"location":"help/#do-you-like-django-ninja","text":"If you like this project, there is a tiny thing you can do to let us know that we're moving in the right direction. Simply give django-ninja a star on github or share this URL on social media: https://django-ninja.rest-framework.com","title":"Do you like Django Ninja?"},{"location":"help/#do-you-want-to-help-us","text":"Pull requests are always welcome. You can inspect our docs for typos and spelling mistakes, and create pull requests or open an issue . If you have any suggestions to improve Django Ninja , please create them as issues on GitHub.","title":"Do you want to help us?"},{"location":"help/#do-you-need-help","text":"Do not hesitate. Go to GitHub issues and describe your question or problem. We'll attempt to address them quickly. Join the chat at our Discord server. Code-on the webdesign and web development company gives commercial consulting for Django-Ninja. If you are looking for support please contact Code-on and we will be in touch with you soon.","title":"Do you need help?"},{"location":"motivation/","text":"Motivation Quote Django Ninja looks basically the same as FastAPI , so why not just use FastAPI? Indeed, Django Ninja is heavily inspired by FastAPI (developed by Sebasti\u00e1n Ram\u00edrez ) That said, there are few issues when it comes to getting FastAPI and Django to work together properly: 1) FastAPI declares to be ORM agnostic (meaning you can use it with SQLAlchemy or the Django ORM), but in reality the Django ORM is not yet ready for async use (it may be in version 4.0 or 4.1), and if you use it in sync mode, you can have a closed connection issue which you will have to overcome with a lot of effort. 2) The dependency injection with arguments makes your code too verbose when you rely on authentication and database sessions in your operations (which for some projects is about 99% of all operations). ... app = FastAPI () # Dependency def get_db (): db = SessionLocal () try : yield db finally : db . close () async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = decode ( token ) if not user : raise HTTPException ( ... ) return user @app . get ( \"/task/ {task_id} \" , response_model = Task ) def read_user ( task_id : int , db : Session = Depends ( get_db ), current_user : User = Depends ( get_current_user ), ): ... use db with current_user .... 3) Since the word model in Django is \"reserved\" for use by the ORM, it becomes very confusing when you mix the Django ORM with Pydantic/FastAPI model naming conventions. Django Ninja Django Ninja addresses all those issues, and integrates very well with Django (ORM, urls, views, auth and more) Working at Code-on a Django webdesign webedevelopment studio I get all sorts of challenges and to solve these I started Django-Ninja in 2020. Note: Django Ninja is a production ready project - my estimation is at this time already 100+ companies using it in production and 500 new developers joining every month. Main Features 1) Since you can have multiple Django Ninja API instances - you can run multiple API versions inside one Django project. api_v1 = NinjaAPI ( version = '1.0' , auth = token_auth ) ... api_v2 = NinjaAPI ( version = '2.0' , auth = token_auth ) ... api_private = NinjaAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), path ( 'internal-api/' , api_private . urls ), ] 2) The Django Ninja 'Schema' class is integrated with the ORM, so you can serialize querysets or ORM objects: @api . get ( \"/tasks\" , response = List [ TaskSchema ]) def tasks ( request ): return Task . objects . all () @api . get ( \"/tasks\" , response = TaskSchema ) def tasks_details ( request ): task = Task . objects . first () return task 3) Create Schema's from Django Models . 4) Instead of dependency arguments, Django Ninja uses request instance attributes (in the same way as regular Django views) - more detail at Authentication .","title":"Motivation"},{"location":"motivation/#motivation","text":"Quote Django Ninja looks basically the same as FastAPI , so why not just use FastAPI? Indeed, Django Ninja is heavily inspired by FastAPI (developed by Sebasti\u00e1n Ram\u00edrez ) That said, there are few issues when it comes to getting FastAPI and Django to work together properly: 1) FastAPI declares to be ORM agnostic (meaning you can use it with SQLAlchemy or the Django ORM), but in reality the Django ORM is not yet ready for async use (it may be in version 4.0 or 4.1), and if you use it in sync mode, you can have a closed connection issue which you will have to overcome with a lot of effort. 2) The dependency injection with arguments makes your code too verbose when you rely on authentication and database sessions in your operations (which for some projects is about 99% of all operations). ... app = FastAPI () # Dependency def get_db (): db = SessionLocal () try : yield db finally : db . close () async def get_current_user ( token : str = Depends ( oauth2_scheme )): user = decode ( token ) if not user : raise HTTPException ( ... ) return user @app . get ( \"/task/ {task_id} \" , response_model = Task ) def read_user ( task_id : int , db : Session = Depends ( get_db ), current_user : User = Depends ( get_current_user ), ): ... use db with current_user .... 3) Since the word model in Django is \"reserved\" for use by the ORM, it becomes very confusing when you mix the Django ORM with Pydantic/FastAPI model naming conventions.","title":"Motivation"},{"location":"motivation/#django-ninja","text":"Django Ninja addresses all those issues, and integrates very well with Django (ORM, urls, views, auth and more) Working at Code-on a Django webdesign webedevelopment studio I get all sorts of challenges and to solve these I started Django-Ninja in 2020. Note: Django Ninja is a production ready project - my estimation is at this time already 100+ companies using it in production and 500 new developers joining every month.","title":"Django Ninja"},{"location":"motivation/#main-features","text":"1) Since you can have multiple Django Ninja API instances - you can run multiple API versions inside one Django project. api_v1 = NinjaAPI ( version = '1.0' , auth = token_auth ) ... api_v2 = NinjaAPI ( version = '2.0' , auth = token_auth ) ... api_private = NinjaAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), path ( 'internal-api/' , api_private . urls ), ] 2) The Django Ninja 'Schema' class is integrated with the ORM, so you can serialize querysets or ORM objects: @api . get ( \"/tasks\" , response = List [ TaskSchema ]) def tasks ( request ): return Task . objects . all () @api . get ( \"/tasks\" , response = TaskSchema ) def tasks_details ( request ): task = Task . objects . first () return task 3) Create Schema's from Django Models . 4) Instead of dependency arguments, Django Ninja uses request instance attributes (in the same way as regular Django views) - more detail at Authentication .","title":"Main Features"},{"location":"releases/","text":"Release Notes Follow and subscribe for new releases on GitHub: https://github.com/vitalik/django-ninja/releases","title":"Release Notes"},{"location":"releases/#release-notes","text":"Follow and subscribe for new releases on GitHub: https://github.com/vitalik/django-ninja/releases","title":"Release Notes"},{"location":"video/","text":"Video Tutorials Creating a CRUD API with Django-Ninja by BugBytes (English)","title":"Video Tutorials"},{"location":"video/#video-tutorials","text":"","title":"Video Tutorials"},{"location":"video/#creating-a-crud-api-with-django-ninja-by-bugbytes-english","text":"","title":"Creating a CRUD API with Django-Ninja by BugBytes (English)"},{"location":"proposals/","text":"Enhancement Proposals Enhancement Proposals are a formal way of proposing large feature additions to the Django Ninja Framework . You can create a proposal by making a pull request with a new page under docs/proposals , or by creating an issue on github . Please see the current proposals: Class Based Operations Schemas from Django models","title":"Intro"},{"location":"proposals/#enhancement-proposals","text":"Enhancement Proposals are a formal way of proposing large feature additions to the Django Ninja Framework . You can create a proposal by making a pull request with a new page under docs/proposals , or by creating an issue on github . Please see the current proposals: Class Based Operations Schemas from Django models","title":"Enhancement Proposals"},{"location":"proposals/cbv/","text":"Class Based Operations This is just a proposal and it is not present in library code , but eventually this can be a part of Django Ninja. Please consider adding likes/dislikes or comments in github issue to express your feeling about this proposal Problem An API operation is a callable which takes a request and parameters and returns a response, but it is often a case in real world when you need to reuse the same pieces of code in multiple operations. Let's take the following example: we have a Todo application with Projects and Tasks each project has multiple tasks each project may also have an owner (user) users should not be able to access projects they do not own Model structure is something like this: class Project ( models . Model ): title = models . CharField ( max_length = 100 ) owner = models . ForeignKey ( 'auth.User' , on_delete = models . CASCADE ) class Task ( models . Model ): project = models . ForeignKey ( Project , on_delete = models . CASCADE ) title = models . CharField ( max_length = 100 ) completed = models . BooleanField () Now, let's create a few API operations for it: a list of tasks for the project some task details a 'complete task' action The code should validate that a user can only access his/her own project's tasks (otherwise, return 404) It can be something like this: router = Router () @router . get ( '/project/ {project_id} /tasks/' , response = List [ TaskOut ]) def task_list ( request ): user_projects = request . user . project_set project = get_object_or_404 ( user_projects , id = project_id )) return project . task_set . all () @router . get ( '/project/ {project_id} /tasks/ {task_id} /' , response = TaskOut ) def details ( request , task_id : int ): user_projects = request . user . project_set project = get_object_or_404 ( user_projects , id = project_id )) user_tasks = project . task_set . all () return get_object_or_404 ( user_tasks , id = task_id ) @router . post ( '/project/ {project_id} /tasks/ {task_id} /complete' , response = TaskOut ) def complete ( request , task_id : int ): user_projects = request . user . project_set project = get_object_or_404 ( user_projects , id = project_id )) user_tasks = project . task_set . all () task = get_object_or_404 ( user_tasks , id = task_id ) task . completed = True task . save () return task As you can see, these lines are getting repeated pretty often to check permission: user_projects = request . user . project_set project = get_object_or_404 ( user_projects , id = project_id )) You can extract it to a function, but it will just make it 3 lines smaller, and it will still be pretty polluted ... Solution The proposal is to have alternative called \"Class Based Operation\" where you can decorate the entire class with a path decorator: from ninja import Router router = Router () @router . path ( '/project/ {project_id} /tasks' ) class Tasks : def __init__ ( self , request , project_id = int ): user_projects = request . user . project_set self . project = get_object_or_404 ( user_projects , id = project_id )) self . tasks = self . project . task_set . all () @router . get ( '/' , response = List [ TaskOut ]) def task_list ( self , request ): return self . tasks @router . get ( '/ {task_id} /' , response = TaskOut ) def details ( self , request , task_id : int ): return get_object_or_404 ( self . tasks , id = task_id ) @router . post ( '/ {task_id} /complete' , response = TaskOut ) def complete ( self , request , task_id : int ): task = get_object_or_404 ( self . tasks , id = task_id ) task . completed = True task . save () return task All common initiation and permission checks are placed in the constructor: @router . path ( '/project/ {project_id} /tasks' ) class Tasks : def __init__ ( self , request , project_id = int ): user_projects = request . user . project_set self . project = get_object_or_404 ( user_projects , id = project_id )) self . tasks = self . project . task_set . all () This makes the main business operation focus only on tasks (exposed as the self.tasks attribute) You can use both api and router instances to support class paths. Issue The __init__ method: def __init__(self, request, project_id=int): Python doesn't support the async keyword for __init__ , so to support async operations we need some other method for initialization, but __init__ sounds the most logical. Your thoughts/proposals Please give you thoughts/likes/dislikes about this proposal in the github issue","title":"Class Based Operations"},{"location":"proposals/cbv/#class-based-operations","text":"This is just a proposal and it is not present in library code , but eventually this can be a part of Django Ninja. Please consider adding likes/dislikes or comments in github issue to express your feeling about this proposal","title":"Class Based Operations"},{"location":"proposals/cbv/#problem","text":"An API operation is a callable which takes a request and parameters and returns a response, but it is often a case in real world when you need to reuse the same pieces of code in multiple operations. Let's take the following example: we have a Todo application with Projects and Tasks each project has multiple tasks each project may also have an owner (user) users should not be able to access projects they do not own Model structure is something like this: class Project ( models . Model ): title = models . CharField ( max_length = 100 ) owner = models . ForeignKey ( 'auth.User' , on_delete = models . CASCADE ) class Task ( models . Model ): project = models . ForeignKey ( Project , on_delete = models . CASCADE ) title = models . CharField ( max_length = 100 ) completed = models . BooleanField () Now, let's create a few API operations for it: a list of tasks for the project some task details a 'complete task' action The code should validate that a user can only access his/her own project's tasks (otherwise, return 404) It can be something like this: router = Router () @router . get ( '/project/ {project_id} /tasks/' , response = List [ TaskOut ]) def task_list ( request ): user_projects = request . user . project_set project = get_object_or_404 ( user_projects , id = project_id )) return project . task_set . all () @router . get ( '/project/ {project_id} /tasks/ {task_id} /' , response = TaskOut ) def details ( request , task_id : int ): user_projects = request . user . project_set project = get_object_or_404 ( user_projects , id = project_id )) user_tasks = project . task_set . all () return get_object_or_404 ( user_tasks , id = task_id ) @router . post ( '/project/ {project_id} /tasks/ {task_id} /complete' , response = TaskOut ) def complete ( request , task_id : int ): user_projects = request . user . project_set project = get_object_or_404 ( user_projects , id = project_id )) user_tasks = project . task_set . all () task = get_object_or_404 ( user_tasks , id = task_id ) task . completed = True task . save () return task As you can see, these lines are getting repeated pretty often to check permission: user_projects = request . user . project_set project = get_object_or_404 ( user_projects , id = project_id )) You can extract it to a function, but it will just make it 3 lines smaller, and it will still be pretty polluted ...","title":"Problem"},{"location":"proposals/cbv/#solution","text":"The proposal is to have alternative called \"Class Based Operation\" where you can decorate the entire class with a path decorator: from ninja import Router router = Router () @router . path ( '/project/ {project_id} /tasks' ) class Tasks : def __init__ ( self , request , project_id = int ): user_projects = request . user . project_set self . project = get_object_or_404 ( user_projects , id = project_id )) self . tasks = self . project . task_set . all () @router . get ( '/' , response = List [ TaskOut ]) def task_list ( self , request ): return self . tasks @router . get ( '/ {task_id} /' , response = TaskOut ) def details ( self , request , task_id : int ): return get_object_or_404 ( self . tasks , id = task_id ) @router . post ( '/ {task_id} /complete' , response = TaskOut ) def complete ( self , request , task_id : int ): task = get_object_or_404 ( self . tasks , id = task_id ) task . completed = True task . save () return task All common initiation and permission checks are placed in the constructor: @router . path ( '/project/ {project_id} /tasks' ) class Tasks : def __init__ ( self , request , project_id = int ): user_projects = request . user . project_set self . project = get_object_or_404 ( user_projects , id = project_id )) self . tasks = self . project . task_set . all () This makes the main business operation focus only on tasks (exposed as the self.tasks attribute) You can use both api and router instances to support class paths.","title":"Solution"},{"location":"proposals/cbv/#issue","text":"The __init__ method: def __init__(self, request, project_id=int): Python doesn't support the async keyword for __init__ , so to support async operations we need some other method for initialization, but __init__ sounds the most logical.","title":"Issue"},{"location":"proposals/cbv/#your-thoughtsproposals","text":"Please give you thoughts/likes/dislikes about this proposal in the github issue","title":"Your thoughts/proposals"},{"location":"proposals/v1/","text":"Potential v1 changes Django Ninja is already used by tens of companies and by the visitors and downloads stats it's growing. At this point introducing changes that will force current users to change their code (or break it) is not acceptable. On the other hand some decisions that where initially made does not work well. These breaking changes will be introduced in version 1.0.0 Changes that most likely be in v1 auth will be class interface instead of callable (to support async authenticators) responses to support codes/headers/content (like general Response class) routers paths currently automatically joined with \"/\" - which might not needed on some cases where router prefix will act like a prefix and not subfolder Your thoughts/proposals Please give you thoughts/likes/dislikes in the github issue .","title":"Potential v1 changes"},{"location":"proposals/v1/#potential-v1-changes","text":"Django Ninja is already used by tens of companies and by the visitors and downloads stats it's growing. At this point introducing changes that will force current users to change their code (or break it) is not acceptable. On the other hand some decisions that where initially made does not work well. These breaking changes will be introduced in version 1.0.0","title":"Potential v1 changes"},{"location":"proposals/v1/#changes-that-most-likely-be-in-v1","text":"auth will be class interface instead of callable (to support async authenticators) responses to support codes/headers/content (like general Response class) routers paths currently automatically joined with \"/\" - which might not needed on some cases where router prefix will act like a prefix and not subfolder","title":"Changes that most likely be in v1"},{"location":"proposals/v1/#your-thoughtsproposals","text":"Please give you thoughts/likes/dislikes in the github issue .","title":"Your thoughts/proposals"},{"location":"tutorial/","text":"Tutorial - Intro This tutorial shows you how to use Django Ninja with most of its features. It is also built to work as reference documentation. This tutorial assumes that you know at least some basics of the Django Framework , like how to create a project and run it. Installation pip install django-ninja Note It is not required, but you can also put ninja to INSTALLED_APPS . In that case the OpenAPI/Swagger UI will be loaded (faster) from the included JavaScript bundle (otherwise the JavaScript bundle comes from a CDN). Create a Django project (If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject First steps Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja import NinjaAPI api = NinjaAPI () @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ] Defining operation methods \"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more Django Ninja comes with a decorator for each method: @api . get ( \"/path\" ) def get_operation ( request ): ... @api . post ( \"/path\" ) def post_operation ( request ): ... @api . put ( \"/path\" ) def put_operation ( request ): ... @api . delete ( \"/path\" ) def delete_operation ( request ): ... @api . patch ( \"/path\" ) def patch_operation ( request ): ... If you need to handle multiple methods with a single function for a given path, you can use the api_operation method: @api . api_operation ([ \"POST\" , \"PATCH\" ], \"/path\" ) def mixed ( request ): ... This feature can also be used to implement other HTTP methods that don't have corresponding django-ninja methods, such as HEAD or OPTIONS . @api . api_operation ([ \"HEAD\" , \"OPTIONS\" ], \"/path\" ) def mixed ( request ): ...","title":"Tutorial - Intro"},{"location":"tutorial/#tutorial-intro","text":"This tutorial shows you how to use Django Ninja with most of its features. It is also built to work as reference documentation. This tutorial assumes that you know at least some basics of the Django Framework , like how to create a project and run it.","title":"Tutorial - Intro"},{"location":"tutorial/#installation","text":"pip install django-ninja Note It is not required, but you can also put ninja to INSTALLED_APPS . In that case the OpenAPI/Swagger UI will be loaded (faster) from the included JavaScript bundle (otherwise the JavaScript bundle comes from a CDN).","title":"Installation"},{"location":"tutorial/#create-a-django-project","text":"(If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject","title":"Create a Django project"},{"location":"tutorial/#first-steps","text":"Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja import NinjaAPI api = NinjaAPI () @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ]","title":"First steps"},{"location":"tutorial/#defining-operation-methods","text":"\"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more Django Ninja comes with a decorator for each method: @api . get ( \"/path\" ) def get_operation ( request ): ... @api . post ( \"/path\" ) def post_operation ( request ): ... @api . put ( \"/path\" ) def put_operation ( request ): ... @api . delete ( \"/path\" ) def delete_operation ( request ): ... @api . patch ( \"/path\" ) def patch_operation ( request ): ... If you need to handle multiple methods with a single function for a given path, you can use the api_operation method: @api . api_operation ([ \"POST\" , \"PATCH\" ], \"/path\" ) def mixed ( request ): ... This feature can also be used to implement other HTTP methods that don't have corresponding django-ninja methods, such as HEAD or OPTIONS . @api . api_operation ([ \"HEAD\" , \"OPTIONS\" ], \"/path\" ) def mixed ( request ): ...","title":"Defining operation methods"},{"location":"tutorial/authentication/","text":"Authentication Intro Django Ninja provides several tools to help you deal with authentication and authorization easily, rapidly, in a standard way, and without having to study and learn all the security specifications . The core concept is that when you describe an API operation, you can define an authentication object. from ninja import NinjaAPI from ninja.security import django_auth api = NinjaAPI ( csrf = True ) @api . get ( \"/pets\" , auth = django_auth ) def pets ( request ): return f \"Authenticated user { request . auth } \" In this example, the client will only be able to call the pets method if it uses Django session authentication (the default is cookie based), otherwise an HTTP-401 error will be returned. Automatic OpenAPI schema Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token @api . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( request ): return { \"token\" : request . auth } Now go to the docs at http://localhost:8000/api/docs . Now, when you click the Authorize button, you will get a prompt to input your authentication token. When you do test calls, the Authorization header will be passed for every request. Global authentication In case you need to secure all methods of your API, you can pass the auth argument to the NinjaAPI constructor: from ninja import NinjaAPI , Form from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaAPI ( auth = GlobalAuth ()) # @api.get(...) # def ... # @api.post(...) # def ... And, if you need to overrule some of those methods, you can do that on the operation level again by passing the auth argument. In this example, authentication will be disabled for the /token operation: from ninja import NinjaAPI , Form from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaAPI ( auth = GlobalAuth ()) # @api.get(...) # def ... # @api.post(...) # def ... @api . post ( \"/token\" , auth = None ) # < overriding global auth def get_token ( request , username : str = Form ( ... ), password : str = Form ( ... )): if username == \"admin\" and password == \"giraffethinnknslong\" : return { \"token\" : \"supersecret\" } Available auth options Custom function The \" auth= \" argument accepts any Callable object. NinjaAPI passes authentication only if the callable object returns a value that can be converted to boolean True . This return value will be assigned to the request.auth attribute. def ip_whitelist ( request ): if request . META [ \"REMOTE_ADDR\" ] == \"8.8.8.8\" : return \"8.8.8.8\" @api . get ( \"/ipwhiltelist\" , auth = ip_whitelist ) def ipwhiltelist ( request ): return f \"Authenticated client, IP = { request . auth } \" API Key Some API's use API keys for authorization. An API key is a token that a client provides when making API calls to identify itself. The key can be sent in the query string: GET /something?api_key=abcdef12345 or as a request header: GET /something HTTP/1.1 X-API-Key: abcdef12345 or as a cookie: GET /something HTTP/1.1 Cookie: X-API-KEY=abcdef12345 Django Ninja comes with built-in classes to help you handle these cases. in Query from ninja.security import APIKeyQuery from someapp.models import Client class ApiKey ( APIKeyQuery ): param_name = \"api_key\" def authenticate ( self , request , key ): try : return Client . objects . get ( key = key ) except Client . DoesNotExist : pass api_key = ApiKey () @api . get ( \"/apikey\" , auth = api_key ) def apikey ( request ): assert isinstance ( request . auth , Client ) return f \"Hello { request . auth } \" In this example we take a token from GET['api_key'] and find a Client in the database that corresponds to this key. The Client instance will be set to the request.auth attribute. Note: param_name is the name of the GET parameter that will be checked for. If not set, the default of \" key \" will be used. in Header from ninja.security import APIKeyHeader class ApiKey ( APIKeyHeader ): param_name = \"X-API-Key\" def authenticate ( self , request , key ): if key == \"supersecret\" : return key header_key = ApiKey () @api . get ( \"/headerkey\" , auth = header_key ) def apikey ( request ): return f \"Token = { request . auth } \" in Cookie from ninja.security import APIKeyCookie class CookieKey ( APIKeyCookie ): def authenticate ( self , request , key ): if key == \"supersecret\" : return key cookie_key = CookieKey () @api . get ( \"/cookiekey\" , auth = cookie_key ) def apikey ( request ): return f \"Token = { request . auth } \" HTTP Bearer from ninja.security import HttpBearer class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token @api . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( request ): return { \"token\" : request . auth } HTTP Basic Auth from ninja.security import HttpBasicAuth class BasicAuth ( HttpBasicAuth ): def authenticate ( self , request , username , password ): if username == \"admin\" and password == \"secret\" : return username @api . get ( \"/basic\" , auth = BasicAuth ()) def basic ( request ): return { \"httpuser\" : request . auth } Multiple authenticators The auth argument also allows you to pass multiple authenticators: from ninja.security import APIKeyQuery , APIKeyHeader class AuthCheck : def authenticate ( self , request , key ): if key == \"supersecret\" : return key class QueryKey ( AuthCheck , APIKeyQuery ): pass class HeaderKey ( AuthCheck , APIKeyHeader ): pass @api . get ( \"/multiple\" , auth = [ QueryKey (), HeaderKey ()]) def multiple ( request ): return f \"Token = { request . auth } \" In this case Django Ninja will first check the API key GET , and if not set or invalid will check the header key. If both are invalid, it will raise an authentication error to the response. Router authentication Use auth argument on Router to apply authenticator to all operations declared in it: api . add_router ( \"/events/\" , events_router , auth = BasicAuth ()) or using router constructor router = Router ( auth = BasicAuth ()) Custom exceptions Raising an exception that has an exception handler will return the response from that handler in the same way an operation would: from ninja import NinjaAPI from ninja.security import HttpBearer api = NinjaAPI () class InvalidToken ( Exception ): pass @api . exception_handler ( InvalidToken ) def on_invalid_token ( request , exc ): return api . create_response ( request , { \"detail\" : \"Invalid token supplied\" }, status = 401 ) class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token raise InvalidToken @api . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( request ): return { \"token\" : request . auth } See Handling errors for more information.","title":"Authentication"},{"location":"tutorial/authentication/#authentication","text":"","title":"Authentication"},{"location":"tutorial/authentication/#intro","text":"Django Ninja provides several tools to help you deal with authentication and authorization easily, rapidly, in a standard way, and without having to study and learn all the security specifications . The core concept is that when you describe an API operation, you can define an authentication object. from ninja import NinjaAPI from ninja.security import django_auth api = NinjaAPI ( csrf = True ) @api . get ( \"/pets\" , auth = django_auth ) def pets ( request ): return f \"Authenticated user { request . auth } \" In this example, the client will only be able to call the pets method if it uses Django session authentication (the default is cookie based), otherwise an HTTP-401 error will be returned.","title":"Intro"},{"location":"tutorial/authentication/#automatic-openapi-schema","text":"Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token @api . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( request ): return { \"token\" : request . auth } Now go to the docs at http://localhost:8000/api/docs . Now, when you click the Authorize button, you will get a prompt to input your authentication token. When you do test calls, the Authorization header will be passed for every request.","title":"Automatic OpenAPI schema"},{"location":"tutorial/authentication/#global-authentication","text":"In case you need to secure all methods of your API, you can pass the auth argument to the NinjaAPI constructor: from ninja import NinjaAPI , Form from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaAPI ( auth = GlobalAuth ()) # @api.get(...) # def ... # @api.post(...) # def ... And, if you need to overrule some of those methods, you can do that on the operation level again by passing the auth argument. In this example, authentication will be disabled for the /token operation: from ninja import NinjaAPI , Form from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaAPI ( auth = GlobalAuth ()) # @api.get(...) # def ... # @api.post(...) # def ... @api . post ( \"/token\" , auth = None ) # < overriding global auth def get_token ( request , username : str = Form ( ... ), password : str = Form ( ... )): if username == \"admin\" and password == \"giraffethinnknslong\" : return { \"token\" : \"supersecret\" }","title":"Global authentication"},{"location":"tutorial/authentication/#available-auth-options","text":"","title":"Available auth options"},{"location":"tutorial/authentication/#custom-function","text":"The \" auth= \" argument accepts any Callable object. NinjaAPI passes authentication only if the callable object returns a value that can be converted to boolean True . This return value will be assigned to the request.auth attribute. def ip_whitelist ( request ): if request . META [ \"REMOTE_ADDR\" ] == \"8.8.8.8\" : return \"8.8.8.8\" @api . get ( \"/ipwhiltelist\" , auth = ip_whitelist ) def ipwhiltelist ( request ): return f \"Authenticated client, IP = { request . auth } \"","title":"Custom function"},{"location":"tutorial/authentication/#api-key","text":"Some API's use API keys for authorization. An API key is a token that a client provides when making API calls to identify itself. The key can be sent in the query string: GET /something?api_key=abcdef12345 or as a request header: GET /something HTTP/1.1 X-API-Key: abcdef12345 or as a cookie: GET /something HTTP/1.1 Cookie: X-API-KEY=abcdef12345 Django Ninja comes with built-in classes to help you handle these cases.","title":"API Key"},{"location":"tutorial/authentication/#in-query","text":"from ninja.security import APIKeyQuery from someapp.models import Client class ApiKey ( APIKeyQuery ): param_name = \"api_key\" def authenticate ( self , request , key ): try : return Client . objects . get ( key = key ) except Client . DoesNotExist : pass api_key = ApiKey () @api . get ( \"/apikey\" , auth = api_key ) def apikey ( request ): assert isinstance ( request . auth , Client ) return f \"Hello { request . auth } \" In this example we take a token from GET['api_key'] and find a Client in the database that corresponds to this key. The Client instance will be set to the request.auth attribute. Note: param_name is the name of the GET parameter that will be checked for. If not set, the default of \" key \" will be used.","title":"in Query"},{"location":"tutorial/authentication/#in-header","text":"from ninja.security import APIKeyHeader class ApiKey ( APIKeyHeader ): param_name = \"X-API-Key\" def authenticate ( self , request , key ): if key == \"supersecret\" : return key header_key = ApiKey () @api . get ( \"/headerkey\" , auth = header_key ) def apikey ( request ): return f \"Token = { request . auth } \"","title":"in Header"},{"location":"tutorial/authentication/#in-cookie","text":"from ninja.security import APIKeyCookie class CookieKey ( APIKeyCookie ): def authenticate ( self , request , key ): if key == \"supersecret\" : return key cookie_key = CookieKey () @api . get ( \"/cookiekey\" , auth = cookie_key ) def apikey ( request ): return f \"Token = { request . auth } \"","title":"in Cookie"},{"location":"tutorial/authentication/#http-bearer","text":"from ninja.security import HttpBearer class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token @api . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( request ): return { \"token\" : request . auth }","title":"HTTP Bearer"},{"location":"tutorial/authentication/#http-basic-auth","text":"from ninja.security import HttpBasicAuth class BasicAuth ( HttpBasicAuth ): def authenticate ( self , request , username , password ): if username == \"admin\" and password == \"secret\" : return username @api . get ( \"/basic\" , auth = BasicAuth ()) def basic ( request ): return { \"httpuser\" : request . auth }","title":"HTTP Basic Auth"},{"location":"tutorial/authentication/#multiple-authenticators","text":"The auth argument also allows you to pass multiple authenticators: from ninja.security import APIKeyQuery , APIKeyHeader class AuthCheck : def authenticate ( self , request , key ): if key == \"supersecret\" : return key class QueryKey ( AuthCheck , APIKeyQuery ): pass class HeaderKey ( AuthCheck , APIKeyHeader ): pass @api . get ( \"/multiple\" , auth = [ QueryKey (), HeaderKey ()]) def multiple ( request ): return f \"Token = { request . auth } \" In this case Django Ninja will first check the API key GET , and if not set or invalid will check the header key. If both are invalid, it will raise an authentication error to the response.","title":"Multiple authenticators"},{"location":"tutorial/authentication/#router-authentication","text":"Use auth argument on Router to apply authenticator to all operations declared in it: api . add_router ( \"/events/\" , events_router , auth = BasicAuth ()) or using router constructor router = Router ( auth = BasicAuth ())","title":"Router authentication"},{"location":"tutorial/authentication/#custom-exceptions","text":"Raising an exception that has an exception handler will return the response from that handler in the same way an operation would: from ninja import NinjaAPI from ninja.security import HttpBearer api = NinjaAPI () class InvalidToken ( Exception ): pass @api . exception_handler ( InvalidToken ) def on_invalid_token ( request , exc ): return api . create_response ( request , { \"detail\" : \"Invalid token supplied\" }, status = 401 ) class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token raise InvalidToken @api . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( request ): return { \"token\" : request . auth } See Handling errors for more information.","title":"Custom exceptions"},{"location":"tutorial/body/","text":"Request Body Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema . Info Under the hood Django Ninja uses Pydantic models with all their power and benefits. The alias Schema was chosen to avoid confusion in code when using Django models, as Pydantic's model class is called Model by default, and conflicts with Django's Model class. Import Schema First, you need to import Schema from ninja : from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items\" ) def create ( request , item : Item ): return item Create your data model Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items\" ) def create ( request , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 } Declare it as a parameter To add it to your path operation , declare it the same way you declared the path and query parameters: from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items\" ) def create ( request , item : Item ): return item ... and declare its type as the model you created, Item . Results With just that Python type declaration, Django Ninja will: Read the body of the request as JSON. Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and meaningful error, indicating exactly where and what the incorrect data was. Give you the received data in the parameter item . Because you declared it in the function to be of type Item , you will also have all the editor support (completion, etc.) for all the attributes and their types. Generate JSON Schema definitions for your models, and you can also use them anywhere else you like if it makes sense for your project. Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UI's . Automatic docs The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs: ... and they will be also used in the API docs inside each path operation that needs them: Editor support In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a dict instead of a Schema object): The previous screenshots were taken with Visual Studio Code . You would get the same editor support with PyCharm and most of the other Python editors. Request body + path parameters You can declare path parameters and body requests at the same time. Django Ninja will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared with Schema should be taken from the request body . from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . put ( \"/items/ {item_id} \" ) def update ( request , item_id : int , item : Item ): return { \"item_id\" : item_id , \"item\" : item . dict ()} Request body + path + query parameters You can also declare body , path and query parameters, all at the same time. Django Ninja will recognize each of them and take the data from the correct place. from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items/ {item_id} \" ) def update ( request , item_id : int , item : Item , q : str ): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } The function parameters will be recognized as follows: If the parameter is also declared in the path , it will be used as a path parameter. If the parameter is of a singular type (like int , float , str , bool , etc.), it will be interpreted as a query parameter. If the parameter is declared to be of the type of Schema (or Pydantic BaseModel ), it will be interpreted as a request body .","title":"Request Body"},{"location":"tutorial/body/#request-body","text":"Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema . Info Under the hood Django Ninja uses Pydantic models with all their power and benefits. The alias Schema was chosen to avoid confusion in code when using Django models, as Pydantic's model class is called Model by default, and conflicts with Django's Model class.","title":"Request Body"},{"location":"tutorial/body/#import-schema","text":"First, you need to import Schema from ninja : from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items\" ) def create ( request , item : Item ): return item","title":"Import Schema"},{"location":"tutorial/body/#create-your-data-model","text":"Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items\" ) def create ( request , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 }","title":"Create your data model"},{"location":"tutorial/body/#declare-it-as-a-parameter","text":"To add it to your path operation , declare it the same way you declared the path and query parameters: from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items\" ) def create ( request , item : Item ): return item ... and declare its type as the model you created, Item .","title":"Declare it as a parameter"},{"location":"tutorial/body/#results","text":"With just that Python type declaration, Django Ninja will: Read the body of the request as JSON. Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and meaningful error, indicating exactly where and what the incorrect data was. Give you the received data in the parameter item . Because you declared it in the function to be of type Item , you will also have all the editor support (completion, etc.) for all the attributes and their types. Generate JSON Schema definitions for your models, and you can also use them anywhere else you like if it makes sense for your project. Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UI's .","title":"Results"},{"location":"tutorial/body/#automatic-docs","text":"The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs: ... and they will be also used in the API docs inside each path operation that needs them:","title":"Automatic docs"},{"location":"tutorial/body/#editor-support","text":"In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a dict instead of a Schema object): The previous screenshots were taken with Visual Studio Code . You would get the same editor support with PyCharm and most of the other Python editors.","title":"Editor support"},{"location":"tutorial/body/#request-body-path-parameters","text":"You can declare path parameters and body requests at the same time. Django Ninja will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared with Schema should be taken from the request body . from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . put ( \"/items/ {item_id} \" ) def update ( request , item_id : int , item : Item ): return { \"item_id\" : item_id , \"item\" : item . dict ()}","title":"Request body + path parameters"},{"location":"tutorial/body/#request-body-path-query-parameters","text":"You can also declare body , path and query parameters, all at the same time. Django Ninja will recognize each of them and take the data from the correct place. from ninja import Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items/ {item_id} \" ) def update ( request , item_id : int , item : Item , q : str ): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } The function parameters will be recognized as follows: If the parameter is also declared in the path , it will be used as a path parameter. If the parameter is of a singular type (like int , float , str , bool , etc.), it will be interpreted as a query parameter. If the parameter is declared to be of the type of Schema (or Pydantic BaseModel ), it will be interpreted as a request body .","title":"Request body + path + query parameters"},{"location":"tutorial/config-pydantic/","text":"Overriding Pydantic Config There are many customizations available for a Django Ninja Schema , via the schema's Pydantic Config class . Info Under the hood Django Ninja uses Pydantic Models with all their power and benefits. The alias Schema was chosen to avoid confusion in code when using Django models, as Pydantic's model class is called Model by default, and conflicts with Django's Model class. Example Camel Case mode One interesting Config attribute is alias_generator . Using Pydantic's example in Django Ninja can look something like: from ninja import Schema def to_camel ( string : str ) -> str : return '' . join ( word . capitalize () for word in string . split ( '_' )) class CamelModelSchema ( Schema ): str_field_name : str float_field_name : float class Config ( Schema . Config ): alias_generator = to_camel Note When overriding the schema's Config , it is necessary to inherit from the base Config class. Custom Config from Django Model When using create_schema , the resulting schema can be used to build another class with a custom config like: from django.contrib.auth.models import User from ninja.orm import create_schema BaseUserSchema = create_schema ( User ) class UserSchema ( BaseUserSchema ): class Config ( BaseUserSchema . Config ): ...","title":"Overriding Pydantic Config"},{"location":"tutorial/config-pydantic/#overriding-pydantic-config","text":"There are many customizations available for a Django Ninja Schema , via the schema's Pydantic Config class . Info Under the hood Django Ninja uses Pydantic Models with all their power and benefits. The alias Schema was chosen to avoid confusion in code when using Django models, as Pydantic's model class is called Model by default, and conflicts with Django's Model class.","title":"Overriding Pydantic Config"},{"location":"tutorial/config-pydantic/#example-camel-case-mode","text":"One interesting Config attribute is alias_generator . Using Pydantic's example in Django Ninja can look something like: from ninja import Schema def to_camel ( string : str ) -> str : return '' . join ( word . capitalize () for word in string . split ( '_' )) class CamelModelSchema ( Schema ): str_field_name : str float_field_name : float class Config ( Schema . Config ): alias_generator = to_camel Note When overriding the schema's Config , it is necessary to inherit from the base Config class.","title":"Example Camel Case mode"},{"location":"tutorial/config-pydantic/#custom-config-from-django-model","text":"When using create_schema , the resulting schema can be used to build another class with a custom config like: from django.contrib.auth.models import User from ninja.orm import create_schema BaseUserSchema = create_schema ( User ) class UserSchema ( BaseUserSchema ): class Config ( BaseUserSchema . Config ): ...","title":"Custom Config from Django Model"},{"location":"tutorial/crud/","text":"CRUD example CRUD - C reate, R etrieve, U pdate, D elete are the four basic functions of persistent storage. This example will show you how to implement these functions with Django Ninja . Let's say you have the following Django models that you need to perform these operations on: class Department ( models . Model ): title = models . CharField ( max_length = 100 ) class Employee ( models . Model ): first_name = models . CharField ( max_length = 100 ) last_name = models . CharField ( max_length = 100 ) department = models . ForeignKey ( Department ) birthdate = models . DateField ( null = True , blank = True ) Now let's create CRUD operations for the Employee model. Create To create an employee lets define an INPUT schema: from datetime import date from ninja import Schema class EmployeeIn ( Schema ): first_name : str last_name : str department_id : int = None birthdate : date = None This schema will be our input payload: @api . post ( \"/employees\" ) def create_employee ( request , payload : EmployeeIn ): employee = Employee . objects . create ( ** payload . dict ()) return { \"id\" : employee . id } Tip Schema objects have .dict() attribute with all the schema attributes represented as a dict. You can pass it as **kwargs to the Django model's create method (or model __init__ ). Retrieve Single object Now to get employee we will define a schema that will describe what our responses will look like. Here we will basically use the same schema as EmployeeIn , but will add an extra attribute id : class EmployeeOut ( Schema ): id : int first_name : str last_name : str department_id : int = None birthdate : date = None Note Defining response schemas are not really required, but when you do define it you will get results validation, documentation and automatic ORM objects to JSON conversions. We will use this schema as the response type for our GET employee view: @api . get ( \"/employees/ {employee_id} \" , response = EmployeeOut ) def get_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) return employee Notice that we simply returned an employee ORM object, without a need to convert it to a dict. The response schema does automatic result validation and conversion to JSON: @api . get ( \"/employees/ {employee_id} \" , response = EmployeeOut ) def get_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) return employee List of objects To output a list of employees, we can reuse the same EmployeeOut schema. We will just set the response schema to a List of EmployeeOut . from typing import List @api . get ( \"/employees\" , response = List [ EmployeeOut ]) def list_employees ( request ): qs = Employee . objects . all () return qs Another cool trick - notice we just returned a Django ORM queryset: @api . get ( \"/employees\" , response = List [ EmployeeOut ]) def list_employees ( request ): qs = Employee . objects . all () return qs It automatically gets evaluated, validated and converted to a JSON list! Update Update is pretty trivial. We just use the PUT method and also pass employee_id : @api . put ( \"/employees/ {employee_id} \" ) def update_employee ( request , employee_id : int , payload : EmployeeIn ): employee = get_object_or_404 ( Employee , id = employee_id ) for attr , value in payload . dict () . items (): setattr ( employee , attr , value ) employee . save () return { \"success\" : True } Note Here we used the payload.dict method to set all object attributes: for attr, value in payload.dict().items() You can also do this more explicit: employee . first_name = payload . first_name employee . last_name = payload . last_name employee . department_id = payload . department_id employee . birthdate = payload . birthdate Delete Delete is also pretty simple. We just get employee by id and delete it from the DB: @api . delete ( \"/employees/ {employee_id} \" ) def delete_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) employee . delete () return { \"success\" : True } Final code Here's a full CRUD example: from datetime import date from typing import List from ninja import NinjaAPI , Schema from django.shortcuts import get_object_or_404 from employees.models import Employee api = NinjaAPI () class EmployeeIn ( Schema ): first_name : str last_name : str department_id : int = None birthdate : date = None class EmployeeOut ( Schema ): id : int first_name : str last_name : str department_id : int = None birthdate : date = None @api . post ( \"/employees\" ) def create_employee ( request , payload : EmployeeIn ): employee = Employee . objects . create ( ** payload . dict ()) return { \"id\" : employee . id } @api . get ( \"/employees/ {employee_id} \" , response = EmployeeOut ) def get_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) return employee @api . get ( \"/employees\" , response = List [ EmployeeOut ]) def list_employees ( request ): qs = Employee . objects . all () return qs @api . put ( \"/employees/ {employee_id} \" ) def update_employee ( request , employee_id : int , payload : EmployeeIn ): employee = get_object_or_404 ( Employee , id = employee_id ) for attr , value in payload . dict () . items (): setattr ( employee , attr , value ) employee . save () return { \"success\" : True } @api . delete ( \"/employees/ {employee_id} \" ) def delete_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) employee . delete () return { \"success\" : True }","title":"CRUD example"},{"location":"tutorial/crud/#crud-example","text":"CRUD - C reate, R etrieve, U pdate, D elete are the four basic functions of persistent storage. This example will show you how to implement these functions with Django Ninja . Let's say you have the following Django models that you need to perform these operations on: class Department ( models . Model ): title = models . CharField ( max_length = 100 ) class Employee ( models . Model ): first_name = models . CharField ( max_length = 100 ) last_name = models . CharField ( max_length = 100 ) department = models . ForeignKey ( Department ) birthdate = models . DateField ( null = True , blank = True ) Now let's create CRUD operations for the Employee model.","title":"CRUD example"},{"location":"tutorial/crud/#create","text":"To create an employee lets define an INPUT schema: from datetime import date from ninja import Schema class EmployeeIn ( Schema ): first_name : str last_name : str department_id : int = None birthdate : date = None This schema will be our input payload: @api . post ( \"/employees\" ) def create_employee ( request , payload : EmployeeIn ): employee = Employee . objects . create ( ** payload . dict ()) return { \"id\" : employee . id } Tip Schema objects have .dict() attribute with all the schema attributes represented as a dict. You can pass it as **kwargs to the Django model's create method (or model __init__ ).","title":"Create"},{"location":"tutorial/crud/#retrieve","text":"","title":"Retrieve"},{"location":"tutorial/crud/#single-object","text":"Now to get employee we will define a schema that will describe what our responses will look like. Here we will basically use the same schema as EmployeeIn , but will add an extra attribute id : class EmployeeOut ( Schema ): id : int first_name : str last_name : str department_id : int = None birthdate : date = None Note Defining response schemas are not really required, but when you do define it you will get results validation, documentation and automatic ORM objects to JSON conversions. We will use this schema as the response type for our GET employee view: @api . get ( \"/employees/ {employee_id} \" , response = EmployeeOut ) def get_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) return employee Notice that we simply returned an employee ORM object, without a need to convert it to a dict. The response schema does automatic result validation and conversion to JSON: @api . get ( \"/employees/ {employee_id} \" , response = EmployeeOut ) def get_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) return employee","title":"Single object"},{"location":"tutorial/crud/#list-of-objects","text":"To output a list of employees, we can reuse the same EmployeeOut schema. We will just set the response schema to a List of EmployeeOut . from typing import List @api . get ( \"/employees\" , response = List [ EmployeeOut ]) def list_employees ( request ): qs = Employee . objects . all () return qs Another cool trick - notice we just returned a Django ORM queryset: @api . get ( \"/employees\" , response = List [ EmployeeOut ]) def list_employees ( request ): qs = Employee . objects . all () return qs It automatically gets evaluated, validated and converted to a JSON list!","title":"List of objects"},{"location":"tutorial/crud/#update","text":"Update is pretty trivial. We just use the PUT method and also pass employee_id : @api . put ( \"/employees/ {employee_id} \" ) def update_employee ( request , employee_id : int , payload : EmployeeIn ): employee = get_object_or_404 ( Employee , id = employee_id ) for attr , value in payload . dict () . items (): setattr ( employee , attr , value ) employee . save () return { \"success\" : True } Note Here we used the payload.dict method to set all object attributes: for attr, value in payload.dict().items() You can also do this more explicit: employee . first_name = payload . first_name employee . last_name = payload . last_name employee . department_id = payload . department_id employee . birthdate = payload . birthdate","title":"Update"},{"location":"tutorial/crud/#delete","text":"Delete is also pretty simple. We just get employee by id and delete it from the DB: @api . delete ( \"/employees/ {employee_id} \" ) def delete_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) employee . delete () return { \"success\" : True }","title":"Delete"},{"location":"tutorial/crud/#final-code","text":"Here's a full CRUD example: from datetime import date from typing import List from ninja import NinjaAPI , Schema from django.shortcuts import get_object_or_404 from employees.models import Employee api = NinjaAPI () class EmployeeIn ( Schema ): first_name : str last_name : str department_id : int = None birthdate : date = None class EmployeeOut ( Schema ): id : int first_name : str last_name : str department_id : int = None birthdate : date = None @api . post ( \"/employees\" ) def create_employee ( request , payload : EmployeeIn ): employee = Employee . objects . create ( ** payload . dict ()) return { \"id\" : employee . id } @api . get ( \"/employees/ {employee_id} \" , response = EmployeeOut ) def get_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) return employee @api . get ( \"/employees\" , response = List [ EmployeeOut ]) def list_employees ( request ): qs = Employee . objects . all () return qs @api . put ( \"/employees/ {employee_id} \" ) def update_employee ( request , employee_id : int , payload : EmployeeIn ): employee = get_object_or_404 ( Employee , id = employee_id ) for attr , value in payload . dict () . items (): setattr ( employee , attr , value ) employee . save () return { \"success\" : True } @api . delete ( \"/employees/ {employee_id} \" ) def delete_employee ( request , employee_id : int ): employee = get_object_or_404 ( Employee , id = employee_id ) employee . delete () return { \"success\" : True }","title":"Final code"},{"location":"tutorial/csrf/","text":"CSRF By default, Django Ninja has CSRF turned OFF for all operations. To turn it on you need to use the csrf argument of the NinjaAPI class: from ninja import NinjaAPI api = NinjaAPI ( csrf = True ) Warning : It is not secure to use API's with cookie-based authentication! (like CookieKey , or django_auth ) Django Ninja will prevent you from doing this. So, if you do this: from ninja import NinjaAPI from ninja.security import django_auth api = NinjaAPI ( auth = django_auth ) it will raise an error. Instead, you need to set the csrf argument to True to enable CSRF checks: from ninja import NinjaAPI from ninja.security import django_auth api = NinjaAPI ( auth = django_auth , csrf = True )","title":"CSRF"},{"location":"tutorial/csrf/#csrf","text":"By default, Django Ninja has CSRF turned OFF for all operations. To turn it on you need to use the csrf argument of the NinjaAPI class: from ninja import NinjaAPI api = NinjaAPI ( csrf = True ) Warning : It is not secure to use API's with cookie-based authentication! (like CookieKey , or django_auth ) Django Ninja will prevent you from doing this. So, if you do this: from ninja import NinjaAPI from ninja.security import django_auth api = NinjaAPI ( auth = django_auth ) it will raise an error. Instead, you need to set the csrf argument to True to enable CSRF checks: from ninja import NinjaAPI from ninja.security import django_auth api = NinjaAPI ( auth = django_auth , csrf = True )","title":"CSRF"},{"location":"tutorial/django-pydantic-create-schema/","text":"Using create_schema Under the hood, ModelSchema uses the create_schema function. This is a more advanced (and less safe) method - please use it carefully. create_schema Django Ninja comes with a helper function create_schema : def create_schema ( model , # django model name = \"\" , # name for the generated class, if empty model names is used depth = 0 , # if > 0 schema will be also created for the nested ForeignKeys and Many2Many (with the provided depth of lookup) fields : list [ str ] = None , # if passed - ONLY these fields will added to schema exclude : list [ str ] = None , # if passed - these fields will be excluded from schema custom_fields : list [ tuple ( str , Any , Any )] = None , # if passed - this will override default field types (or add new fields) ) Take this example: from django.contrib.auth.models import User from ninja.orm import create_schema UserSchema = create_schema ( User ) # Will create schema like this: # # class UserSchema(Schema): # id: int # username: str # first_name: str # last_name: str # password: str # last_login: datetime # is_superuser: bool # email: str # ... and the rest Warning By default create_schema builds a schema with ALL model fields. This can lead to accidental unwanted data exposure (like hashed password, in the above example). Always use fields or exclude arguments to explicitly define list of attributes. Using fields UserSchema = create_schema ( User , fields = [ 'id' , 'username' ]) # Will create schema like this: # # class UserSchema(Schema): # id: int # username: str Using exclude UserSchema = create_schema ( User , exclude = [ 'password' , 'last_login' , 'is_superuser' , 'is_staff' , 'groups' , 'user_permissions' ] ) # Will create schema without excluded fields: # # class UserSchema(Schema): # id: int # username: str # first_name: str # last_name: str # email: str # is_active: bool # date_joined: datetime Using depth The depth argument allows you to introspect the Django model into the Related fields(ForeignKey, OneToOne, ManyToMany). UserSchema = create_schema ( User , depth = 1 , fields = [ 'username' , 'groups' ]) # Will create the following schema: # # class UserSchema(Schema): # username: str # groups: List[Group] Note here that groups became a List[Group] - many2many field introspected 1 level deeper and created schema as well for group: class Group ( Schema ): id : int name : str permissions : List [ int ]","title":"Using create_schema"},{"location":"tutorial/django-pydantic-create-schema/#using-create_schema","text":"Under the hood, ModelSchema uses the create_schema function. This is a more advanced (and less safe) method - please use it carefully.","title":"Using create_schema"},{"location":"tutorial/django-pydantic-create-schema/#create_schema","text":"Django Ninja comes with a helper function create_schema : def create_schema ( model , # django model name = \"\" , # name for the generated class, if empty model names is used depth = 0 , # if > 0 schema will be also created for the nested ForeignKeys and Many2Many (with the provided depth of lookup) fields : list [ str ] = None , # if passed - ONLY these fields will added to schema exclude : list [ str ] = None , # if passed - these fields will be excluded from schema custom_fields : list [ tuple ( str , Any , Any )] = None , # if passed - this will override default field types (or add new fields) ) Take this example: from django.contrib.auth.models import User from ninja.orm import create_schema UserSchema = create_schema ( User ) # Will create schema like this: # # class UserSchema(Schema): # id: int # username: str # first_name: str # last_name: str # password: str # last_login: datetime # is_superuser: bool # email: str # ... and the rest Warning By default create_schema builds a schema with ALL model fields. This can lead to accidental unwanted data exposure (like hashed password, in the above example). Always use fields or exclude arguments to explicitly define list of attributes.","title":"create_schema"},{"location":"tutorial/django-pydantic-create-schema/#using-fields","text":"UserSchema = create_schema ( User , fields = [ 'id' , 'username' ]) # Will create schema like this: # # class UserSchema(Schema): # id: int # username: str","title":"Using fields"},{"location":"tutorial/django-pydantic-create-schema/#using-exclude","text":"UserSchema = create_schema ( User , exclude = [ 'password' , 'last_login' , 'is_superuser' , 'is_staff' , 'groups' , 'user_permissions' ] ) # Will create schema without excluded fields: # # class UserSchema(Schema): # id: int # username: str # first_name: str # last_name: str # email: str # is_active: bool # date_joined: datetime","title":"Using exclude"},{"location":"tutorial/django-pydantic-create-schema/#using-depth","text":"The depth argument allows you to introspect the Django model into the Related fields(ForeignKey, OneToOne, ManyToMany). UserSchema = create_schema ( User , depth = 1 , fields = [ 'username' , 'groups' ]) # Will create the following schema: # # class UserSchema(Schema): # username: str # groups: List[Group] Note here that groups became a List[Group] - many2many field introspected 1 level deeper and created schema as well for group: class Group ( Schema ): id : int name : str permissions : List [ int ]","title":"Using depth"},{"location":"tutorial/django-pydantic/","text":"Schemas from Django models Schemas are very useful to define your validation rules and responses, but sometimes you need to reflect your database models into schemas and keep changes in sync. ModelSchema ModelSchema is a special base class that can automatically generate schemas from your models. All you need is to set model and model_fields attributes on your schema Config : from django.contrib.auth.models import User from ninja import ModelSchema class UserSchema ( ModelSchema ): class Config : model = User model_fields = [ 'id' , 'username' , 'first_name' , 'last_name' ] # Will create schema like this: # # class UserSchema(Schema): # id: int # username: str # first_name: str # last_name: str Using ALL model fields To use all fields from a model - you can pass __all__ to model_fields : class UserSchema ( ModelSchema ): class Config : model = User model_fields = \"__all__\" Warning Using all is not recommended. This can lead to accidental unwanted data exposure (like hashed password, in the above example). General advice - use model_fields to explicitly define list of fields that you want to be visible in API. Excluding model fields To use all fields except a few, you can use model_exclude configuration: class UserSchema ( ModelSchema ): class Config : model = User model_exclude = [ 'password' , 'last_login' , 'user_permissions' ] # Will create schema like this: # # class UserSchema(Schema): # id: int # username: str # first_name: str # last_name: str # email: str # is_superuser: bool # ... and the rest Overriding fields To change default annotation for some field, or to add a new field, just use annotated attributes as usual. class GroupSchema ( ModelSchema ): class Config : model = Group model_fields = [ 'id' , 'name' ] class UserSchema ( ModelSchema ): groups : List [ GroupSchema ] = [] class Config : model = User model_fields = [ 'id' , 'username' , 'first_name' , 'last_name' ]","title":"Schemas from Django models"},{"location":"tutorial/django-pydantic/#schemas-from-django-models","text":"Schemas are very useful to define your validation rules and responses, but sometimes you need to reflect your database models into schemas and keep changes in sync.","title":"Schemas from Django models"},{"location":"tutorial/django-pydantic/#modelschema","text":"ModelSchema is a special base class that can automatically generate schemas from your models. All you need is to set model and model_fields attributes on your schema Config : from django.contrib.auth.models import User from ninja import ModelSchema class UserSchema ( ModelSchema ): class Config : model = User model_fields = [ 'id' , 'username' , 'first_name' , 'last_name' ] # Will create schema like this: # # class UserSchema(Schema): # id: int # username: str # first_name: str # last_name: str","title":"ModelSchema"},{"location":"tutorial/django-pydantic/#using-all-model-fields","text":"To use all fields from a model - you can pass __all__ to model_fields : class UserSchema ( ModelSchema ): class Config : model = User model_fields = \"__all__\" Warning Using all is not recommended. This can lead to accidental unwanted data exposure (like hashed password, in the above example). General advice - use model_fields to explicitly define list of fields that you want to be visible in API.","title":"Using ALL model fields"},{"location":"tutorial/django-pydantic/#excluding-model-fields","text":"To use all fields except a few, you can use model_exclude configuration: class UserSchema ( ModelSchema ): class Config : model = User model_exclude = [ 'password' , 'last_login' , 'user_permissions' ] # Will create schema like this: # # class UserSchema(Schema): # id: int # username: str # first_name: str # last_name: str # email: str # is_superuser: bool # ... and the rest","title":"Excluding model fields"},{"location":"tutorial/django-pydantic/#overriding-fields","text":"To change default annotation for some field, or to add a new field, just use annotated attributes as usual. class GroupSchema ( ModelSchema ): class Config : model = Group model_fields = [ 'id' , 'name' ] class UserSchema ( ModelSchema ): groups : List [ GroupSchema ] = [] class Config : model = User model_fields = [ 'id' , 'username' , 'first_name' , 'last_name' ]","title":"Overriding fields"},{"location":"tutorial/errors/","text":"Handling errors Django Ninja allows you to install custom exception handlers to deal with how you return responses when errors or handled exceptions occur. Custom exception handlers Let's say you are making API that depends on some external service that is designed to be unavailable at some moments. Instead of throwing default 500 error upon exception - you can handle the error and give some friendly response back to the client (to come back later) To achieve that you need: 1) create some exception (or use existing one) 2) use api.exception_handler decorator Example: api = NinjaAPI () class ServiceUnavailableError ( Exception ): pass # initializing handler @api . exception_handler ( ServiceUnavailableError ) def service_unavailable ( request , exc ): return api . create_response ( request , { \"message\" : \"Please retry later\" }, status = 503 , ) # some logic that throws exception @api . get ( \"/service\" ) def some_operation ( request ): if random . choice ([ True , False ]): raise ServiceUnavailableError () return { \"message\" : \"Hello\" } Exception handler function takes 2 arguments: request - Django http request exc - actual exception function must return http response Override the default exception handlers By default, Django Ninja initialized the following exception handlers: ninja.errors.ValidationError Raised when request data does not validate ninja.errors.HttpError Used to throw http error with status code from any place of the code django.http.Http404 Django's default 404 exception (can be returned f.e. with get_object_or_404 ) Exception Any other unhandled exception by application. Default behavior if settings.DEBUG is True - returns a traceback in plain text (useful when debugging in console or swagger UI) else - default django exception handler mechanism is used (error logging, email to ADMINS) Override default handler If you need to change default output for validation errors - override ValidationError exception handler: from ninja.errors import ValidationError ... @api . exception_handler ( ValidationError ) def validation_errors ( request , exc ): return HttpResponse ( \"Invalid input\" , status_code = 422 ) Throwing HTTP responses with exceptions As an alternative to custom exceptions and writing handlers for it - you can as well throw http exception that will lead to returning a http response with desired code from ninja.errors import HttpError @api . get ( \"/some/resource\" ) def some_operation ( request ): if True : raise HttpError ( 503 , \"Service Unavailable. Please retry later.\" )","title":"Handling errors"},{"location":"tutorial/errors/#handling-errors","text":"Django Ninja allows you to install custom exception handlers to deal with how you return responses when errors or handled exceptions occur.","title":"Handling errors"},{"location":"tutorial/errors/#custom-exception-handlers","text":"Let's say you are making API that depends on some external service that is designed to be unavailable at some moments. Instead of throwing default 500 error upon exception - you can handle the error and give some friendly response back to the client (to come back later) To achieve that you need: 1) create some exception (or use existing one) 2) use api.exception_handler decorator Example: api = NinjaAPI () class ServiceUnavailableError ( Exception ): pass # initializing handler @api . exception_handler ( ServiceUnavailableError ) def service_unavailable ( request , exc ): return api . create_response ( request , { \"message\" : \"Please retry later\" }, status = 503 , ) # some logic that throws exception @api . get ( \"/service\" ) def some_operation ( request ): if random . choice ([ True , False ]): raise ServiceUnavailableError () return { \"message\" : \"Hello\" } Exception handler function takes 2 arguments: request - Django http request exc - actual exception function must return http response","title":"Custom exception handlers"},{"location":"tutorial/errors/#override-the-default-exception-handlers","text":"By default, Django Ninja initialized the following exception handlers:","title":"Override the default exception handlers"},{"location":"tutorial/errors/#ninjaerrorsvalidationerror","text":"Raised when request data does not validate","title":"ninja.errors.ValidationError"},{"location":"tutorial/errors/#ninjaerrorshttperror","text":"Used to throw http error with status code from any place of the code","title":"ninja.errors.HttpError"},{"location":"tutorial/errors/#djangohttphttp404","text":"Django's default 404 exception (can be returned f.e. with get_object_or_404 )","title":"django.http.Http404"},{"location":"tutorial/errors/#exception","text":"Any other unhandled exception by application. Default behavior if settings.DEBUG is True - returns a traceback in plain text (useful when debugging in console or swagger UI) else - default django exception handler mechanism is used (error logging, email to ADMINS)","title":"Exception"},{"location":"tutorial/errors/#override-default-handler","text":"If you need to change default output for validation errors - override ValidationError exception handler: from ninja.errors import ValidationError ... @api . exception_handler ( ValidationError ) def validation_errors ( request , exc ): return HttpResponse ( \"Invalid input\" , status_code = 422 )","title":"Override default handler"},{"location":"tutorial/errors/#throwing-http-responses-with-exceptions","text":"As an alternative to custom exceptions and writing handlers for it - you can as well throw http exception that will lead to returning a http response with desired code from ninja.errors import HttpError @api . get ( \"/some/resource\" ) def some_operation ( request ): if True : raise HttpError ( 503 , \"Service Unavailable. Please retry later.\" )","title":"Throwing HTTP responses with exceptions"},{"location":"tutorial/file-params/","text":"File uploads Handling files are no different from other parameters. from ninja import NinjaAPI , File from ninja.files import UploadedFile @api . post ( \"/upload\" ) def upload ( request , file : UploadedFile = File ( ... )): data = file . read () return { 'name' : file . name , 'len' : len ( data )} UploadedFile is an alias to Django's UploadFile and has all the methods and attributes to access the uploaded file: read() multiple_chunks(chunk_size=None) chunks(chunk_size=None) name size content_type etc. To upload several files at the same time, just declare a List of UploadFile : from typing import List from ninja import NinjaAPI , File from ninja.files import UploadedFile @api . post ( \"/upload-many\" ) def upload_many ( request , files : List [ UploadedFile ] = File ( ... )): return [ f . name for f in files ]","title":"File uploads"},{"location":"tutorial/file-params/#file-uploads","text":"Handling files are no different from other parameters. from ninja import NinjaAPI , File from ninja.files import UploadedFile @api . post ( \"/upload\" ) def upload ( request , file : UploadedFile = File ( ... )): data = file . read () return { 'name' : file . name , 'len' : len ( data )} UploadedFile is an alias to Django's UploadFile and has all the methods and attributes to access the uploaded file: read() multiple_chunks(chunk_size=None) chunks(chunk_size=None) name size content_type etc. To upload several files at the same time, just declare a List of UploadFile : from typing import List from ninja import NinjaAPI , File from ninja.files import UploadedFile @api . post ( \"/upload-many\" ) def upload_many ( request , files : List [ UploadedFile ] = File ( ... )): return [ f . name for f in files ]","title":"File uploads"},{"location":"tutorial/form-params/","text":"Form data Django Ninja also allows you to parse and validate request.POST data (aka application x-www-form-urlencoded or multipart/form-data ). Form Data as params from ninja import NinjaAPI , Form @api . post ( \"/login\" ) def login ( request , username : str = Form ( ... ), password : str = Form ( ... )): return { 'username' : username , 'password' : '*****' } Note the following: 1) You need to import the Form class from ninja from ninja import Form 2) Use Form as default value for your parameter: username : str = Form ( ... ) Using a Schema In a similar manner to Body , you can use a Schema to organize your parameters. from ninja import Form , Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items\" ) def create ( request , item : Item = Form ( ... )): return item Request form + path + query parameters In a similar manner to Body , you can use Form data in combination with other parameter sources. You can declare query and path and form field, and etc... parameters at the same time. Django Ninja will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared with Form(...) should be taken from the request form fields , etc. from ninja import Form , Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items/ {item_id} \" ) def update ( request , item_id : int , q : str , item : Item = Form ( ... )): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q } Mapping Empty Form Field to Default Form fields that are optional, are often sent with an empty value. This value is interpreted as an empty string, and thus may fail validation for fields such as int or bool . This can be fixed, as described in the Pydantic docs, by using Generic Classes as Types . from ninja import Form , Schema from pydantic.fields import ModelField from typing import Generic , TypeVar PydanticField = TypeVar ( \"PydanticField\" ) class EmptyStrToDefault ( Generic [ PydanticField ]): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , value : PydanticField , field : ModelField ) -> PydanticField : if value == \"\" : return field . default return value class Item ( Schema ): name : str description : str = None price : EmptyStrToDefault [ float ] = 0.0 quantity : EmptyStrToDefault [ int ] = 0 in_stock : EmptyStrToDefault [ bool ] = True @api . post ( \"/items-blank-default\" ) def update ( request , item : Item = Form ( ... )): return item . dict ()","title":"Form data"},{"location":"tutorial/form-params/#form-data","text":"Django Ninja also allows you to parse and validate request.POST data (aka application x-www-form-urlencoded or multipart/form-data ).","title":"Form data"},{"location":"tutorial/form-params/#form-data-as-params","text":"from ninja import NinjaAPI , Form @api . post ( \"/login\" ) def login ( request , username : str = Form ( ... ), password : str = Form ( ... )): return { 'username' : username , 'password' : '*****' } Note the following: 1) You need to import the Form class from ninja from ninja import Form 2) Use Form as default value for your parameter: username : str = Form ( ... )","title":"Form Data as params"},{"location":"tutorial/form-params/#using-a-schema","text":"In a similar manner to Body , you can use a Schema to organize your parameters. from ninja import Form , Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items\" ) def create ( request , item : Item = Form ( ... )): return item","title":"Using a Schema"},{"location":"tutorial/form-params/#request-form-path-query-parameters","text":"In a similar manner to Body , you can use Form data in combination with other parameter sources. You can declare query and path and form field, and etc... parameters at the same time. Django Ninja will recognize that the function parameters that match path parameters should be taken from the path , and that function parameters that are declared with Form(...) should be taken from the request form fields , etc. from ninja import Form , Schema class Item ( Schema ): name : str description : str = None price : float quantity : int @api . post ( \"/items/ {item_id} \" ) def update ( request , item_id : int , q : str , item : Item = Form ( ... )): return { \"item_id\" : item_id , \"item\" : item . dict (), \"q\" : q }","title":"Request form + path + query parameters"},{"location":"tutorial/form-params/#mapping-empty-form-field-to-default","text":"Form fields that are optional, are often sent with an empty value. This value is interpreted as an empty string, and thus may fail validation for fields such as int or bool . This can be fixed, as described in the Pydantic docs, by using Generic Classes as Types . from ninja import Form , Schema from pydantic.fields import ModelField from typing import Generic , TypeVar PydanticField = TypeVar ( \"PydanticField\" ) class EmptyStrToDefault ( Generic [ PydanticField ]): @classmethod def __get_validators__ ( cls ): yield cls . validate @classmethod def validate ( cls , value : PydanticField , field : ModelField ) -> PydanticField : if value == \"\" : return field . default return value class Item ( Schema ): name : str description : str = None price : EmptyStrToDefault [ float ] = 0.0 quantity : EmptyStrToDefault [ int ] = 0 in_stock : EmptyStrToDefault [ bool ] = True @api . post ( \"/items-blank-default\" ) def update ( request , item : Item = Form ( ... )): return item . dict ()","title":"Mapping Empty Form Field to Default"},{"location":"tutorial/operation_params/","text":"Operations parameters Tags You can group your API operations using the tags argument ( list[str] ). @api . get ( \"/hello/\" ) def hello ( request , name : str ): return { \"hello\" : name } @api . post ( \"/orders/\" , tags = [ \"orders\" ]) def create_order ( request , order : Order ): return { \"success\" : True } Tagged operations may be handled differently by various tools and libraries. For example, the Swagger UI uses tags to group the displayed operations. Router tags You can use tags argument to apply tags to all operations declared by router: api . add_router ( \"/events/\" , events_router , tags = [ \"events\" ]) # or using constructor: router = Router ( tags = [ \"events\" ]) Operation: Summary Summary is a human-readable name for your operation. By default, it's generated by capitalizing your operation function name: @api . get ( \"/hello/\" ) def hello ( request , name : str ): return { \"hello\" : name } If you want to override it or translate it to other language, use the summary argument in the api decorator. @api . get ( \"/hello/\" , summary = \"Say Hello\" ) def hello ( request , name : str ): return { \"hello\" : name } Operation: Description If you need to provide more information about your operation, use either the description argument or normal Python docstrings: @api . post ( \"/orders/\" , description = \"Creates an order and updates stock\" ) def create_order ( request , order : Order ): return { \"success\" : True } When you need to provide a long multi line description, you can use Python docstrings for the function definition: @api . post ( \"/orders/\" ) def create_order ( request , order : Order ): \"\"\" To create an order please provide: - **first_name** - **last_name** - and **list of Items** *(product + amount)* \"\"\" return { \"success\" : True } OpenAPI operationId The OpenAPI operationId is an optional unique string used to identify an operation. If provided, these IDs must be unique among all operations described in your API. By default, Django Ninja sets it to module name + function name . If you want to set it individually for each operation, use the operation_id argument: ... @api . post ( \"/tasks\" , operation_id = \"create_task\" ) def new_task ( request ): ... If you want to override global behavior, you can inherit the NinjaAPI instance and override the get_openapi_operation_id method. It will be called for each operation that you defined, so you can set your custom naming logic like this: from ninja import NinjaAPI class MySuperApi ( NinjaAPI ): def get_openapi_operation_id ( self , operation ): # here you can access operation ( .path , .view_func, etc) return ... api = MySuperApi () @api . get ( ... ) ... Operation: Deprecated If you need to mark an operation as deprecated without removing it, use the deprecated argument: @api . post ( \"/make-order/\" , deprecated = True ) def some_old_method ( request , order : str ): return { \"success\" : True } It will be marked as deprecated in the JSON Schema and also in the interactive OpenAPI docs: Response output options There are a few arguments that lets you tune response's output: by_alias Whether field aliases should be used as keys in the response (defaults to False ). exclude_unset Whether fields that were not set when creating the schema, and have their default values, should be excluded from the response (defaults to False ). exclude_defaults Whether fields which are equal to their default values (whether set or otherwise) should be excluded from the response (defaults to False ). exclude_none Whether fields which are equal to None should be excluded from the response (defaults to False ). Include/Exclude operation from schema(docs) If you need to exclude some operation from OpenAPI schema use include_in_schema argument: @api . post ( \"/hidden\" , include_in_schema = False ) def some_hiden_operation ( request ): pass url_name Allows you to set api endpoint url name (using django path's naming ) @api . post ( \"/tasks\" , url_name = 'tasks' ) def some_operation ( request ): pass # then you can get the url with reverse ( 'api-1.0.0:tasks' )","title":"Operations parameters"},{"location":"tutorial/operation_params/#operations-parameters","text":"","title":"Operations parameters"},{"location":"tutorial/operation_params/#tags","text":"You can group your API operations using the tags argument ( list[str] ). @api . get ( \"/hello/\" ) def hello ( request , name : str ): return { \"hello\" : name } @api . post ( \"/orders/\" , tags = [ \"orders\" ]) def create_order ( request , order : Order ): return { \"success\" : True } Tagged operations may be handled differently by various tools and libraries. For example, the Swagger UI uses tags to group the displayed operations.","title":"Tags"},{"location":"tutorial/operation_params/#router-tags","text":"You can use tags argument to apply tags to all operations declared by router: api . add_router ( \"/events/\" , events_router , tags = [ \"events\" ]) # or using constructor: router = Router ( tags = [ \"events\" ])","title":"Router tags"},{"location":"tutorial/operation_params/#operation-summary","text":"Summary is a human-readable name for your operation. By default, it's generated by capitalizing your operation function name: @api . get ( \"/hello/\" ) def hello ( request , name : str ): return { \"hello\" : name } If you want to override it or translate it to other language, use the summary argument in the api decorator. @api . get ( \"/hello/\" , summary = \"Say Hello\" ) def hello ( request , name : str ): return { \"hello\" : name }","title":"Operation: Summary"},{"location":"tutorial/operation_params/#operation-description","text":"If you need to provide more information about your operation, use either the description argument or normal Python docstrings: @api . post ( \"/orders/\" , description = \"Creates an order and updates stock\" ) def create_order ( request , order : Order ): return { \"success\" : True } When you need to provide a long multi line description, you can use Python docstrings for the function definition: @api . post ( \"/orders/\" ) def create_order ( request , order : Order ): \"\"\" To create an order please provide: - **first_name** - **last_name** - and **list of Items** *(product + amount)* \"\"\" return { \"success\" : True }","title":"Operation: Description"},{"location":"tutorial/operation_params/#openapi-operationid","text":"The OpenAPI operationId is an optional unique string used to identify an operation. If provided, these IDs must be unique among all operations described in your API. By default, Django Ninja sets it to module name + function name . If you want to set it individually for each operation, use the operation_id argument: ... @api . post ( \"/tasks\" , operation_id = \"create_task\" ) def new_task ( request ): ... If you want to override global behavior, you can inherit the NinjaAPI instance and override the get_openapi_operation_id method. It will be called for each operation that you defined, so you can set your custom naming logic like this: from ninja import NinjaAPI class MySuperApi ( NinjaAPI ): def get_openapi_operation_id ( self , operation ): # here you can access operation ( .path , .view_func, etc) return ... api = MySuperApi () @api . get ( ... ) ...","title":"OpenAPI operationId"},{"location":"tutorial/operation_params/#operation-deprecated","text":"If you need to mark an operation as deprecated without removing it, use the deprecated argument: @api . post ( \"/make-order/\" , deprecated = True ) def some_old_method ( request , order : str ): return { \"success\" : True } It will be marked as deprecated in the JSON Schema and also in the interactive OpenAPI docs:","title":"Operation: Deprecated"},{"location":"tutorial/operation_params/#response-output-options","text":"There are a few arguments that lets you tune response's output:","title":"Response output options"},{"location":"tutorial/operation_params/#by_alias","text":"Whether field aliases should be used as keys in the response (defaults to False ).","title":"by_alias"},{"location":"tutorial/operation_params/#exclude_unset","text":"Whether fields that were not set when creating the schema, and have their default values, should be excluded from the response (defaults to False ).","title":"exclude_unset"},{"location":"tutorial/operation_params/#exclude_defaults","text":"Whether fields which are equal to their default values (whether set or otherwise) should be excluded from the response (defaults to False ).","title":"exclude_defaults"},{"location":"tutorial/operation_params/#exclude_none","text":"Whether fields which are equal to None should be excluded from the response (defaults to False ).","title":"exclude_none"},{"location":"tutorial/operation_params/#includeexclude-operation-from-schemadocs","text":"If you need to exclude some operation from OpenAPI schema use include_in_schema argument: @api . post ( \"/hidden\" , include_in_schema = False ) def some_hiden_operation ( request ): pass","title":"Include/Exclude operation from schema(docs)"},{"location":"tutorial/operation_params/#url_name","text":"Allows you to set api endpoint url name (using django path's naming ) @api . post ( \"/tasks\" , url_name = 'tasks' ) def some_operation ( request ): pass # then you can get the url with reverse ( 'api-1.0.0:tasks' )","title":"url_name"},{"location":"tutorial/pagination/","text":"Pagination (beta) Django Ninja comes with a pagination. This allows you to split large result sets into individual pages. To apply pagination to a function - just apply paginate decorator: from ninja.pagination import paginate @api . get ( '/users' , response = List [ UserSchema ]) @paginate def list_users ( request , ** kwargs ): return User . objects . all () Note Once you applied pagination - you need also add **kwargs parameters to your function (it will store pagination filters) That's it! Now you can query users with limit and offset GET parameters /api/users?limit=10&offset=0 by default limit is set to 100 (you can change it in your settings.py using NINJA_PAGINATION_PER_PAGE ) Built in Pagination Classes LimitOffsetPagination (default) This is the default pagination class (You can change it in your settings.py using NINJA_PAGINATION_CLASS path to a class) from ninja.pagination import paginate , LimitOffsetPagination @api . get ( '/users' , response = List [ UserSchema ]) @paginate ( LimitOffsetPagination ) def list_users ( request , ** kwargs ): return User . objects . all () Example query: /api/users?limit=10&offset=0 this class has two input parameters: limit - defines a number of items on the page (default = 100, change in NINJA_PAGINATION_PER_PAGE) offset - set's the page window offset (default: 0, indexing starts with 0) PageNumberPagination from ninja.pagination import paginate , PageNumberPagination @api . get ( '/users' , response = List [ UserSchema ]) @paginate ( PageNumberPagination ) def list_users ( request , ** kwargs ): return User . objects . all () Example query: /api/users?page=2 this class has one parameter page and outputs 100 items per page by default (can be changed with settings.py) Page numbering start with 1 you can also set custom page_size value individually per view: @api . get ( \"/users\" ) @paginate ( PageNumberPagination , page_size = 50 ) def list_users ( ... Creating Custom Pagination Class To create a custom pagination class you should subclass ninja.pagination.PaginationBase and override the Input schema class and paginate_queryset(self, items, request, **params) method: The Input schema is a Schema class that describes parameters that should be passed to your paginator (f.e. page-number or limit/offset values). The paginate_queryset method is passed the initial queryset and should return an iterable object that contains only the data in the requested page. This method accepts the following arguments: items : a queryset (or iterable) returned by the api function request : django http request object **params : kwargs that will contain all the arguments that decorated function received (to access pagination input get params[\"pagination\"] - it will be a validated instance of your Input class) Example: from ninja.pagination import paginate , PaginationBase from ninja import Schema class CustomPagination ( PaginationBase ): # only `skip` param, defaults to 5 per page class Input ( Schema ): skip : int def paginate_queryset ( self , items , request , ** params ): skip = params [ \"pagination\" ] . skip return items [ skip : skip + 5 ] @api . get ( '/users' , response = List [ UserSchema ]) @paginate ( CustomPagination ) def list_users ( request , ** kwargs ): return User . objects . all ()","title":"Pagination (beta)"},{"location":"tutorial/pagination/#pagination-beta","text":"Django Ninja comes with a pagination. This allows you to split large result sets into individual pages. To apply pagination to a function - just apply paginate decorator: from ninja.pagination import paginate @api . get ( '/users' , response = List [ UserSchema ]) @paginate def list_users ( request , ** kwargs ): return User . objects . all () Note Once you applied pagination - you need also add **kwargs parameters to your function (it will store pagination filters) That's it! Now you can query users with limit and offset GET parameters /api/users?limit=10&offset=0 by default limit is set to 100 (you can change it in your settings.py using NINJA_PAGINATION_PER_PAGE )","title":"Pagination (beta)"},{"location":"tutorial/pagination/#built-in-pagination-classes","text":"","title":"Built in Pagination Classes"},{"location":"tutorial/pagination/#limitoffsetpagination-default","text":"This is the default pagination class (You can change it in your settings.py using NINJA_PAGINATION_CLASS path to a class) from ninja.pagination import paginate , LimitOffsetPagination @api . get ( '/users' , response = List [ UserSchema ]) @paginate ( LimitOffsetPagination ) def list_users ( request , ** kwargs ): return User . objects . all () Example query: /api/users?limit=10&offset=0 this class has two input parameters: limit - defines a number of items on the page (default = 100, change in NINJA_PAGINATION_PER_PAGE) offset - set's the page window offset (default: 0, indexing starts with 0)","title":"LimitOffsetPagination (default)"},{"location":"tutorial/pagination/#pagenumberpagination","text":"from ninja.pagination import paginate , PageNumberPagination @api . get ( '/users' , response = List [ UserSchema ]) @paginate ( PageNumberPagination ) def list_users ( request , ** kwargs ): return User . objects . all () Example query: /api/users?page=2 this class has one parameter page and outputs 100 items per page by default (can be changed with settings.py) Page numbering start with 1 you can also set custom page_size value individually per view: @api . get ( \"/users\" ) @paginate ( PageNumberPagination , page_size = 50 ) def list_users ( ...","title":"PageNumberPagination"},{"location":"tutorial/pagination/#creating-custom-pagination-class","text":"To create a custom pagination class you should subclass ninja.pagination.PaginationBase and override the Input schema class and paginate_queryset(self, items, request, **params) method: The Input schema is a Schema class that describes parameters that should be passed to your paginator (f.e. page-number or limit/offset values). The paginate_queryset method is passed the initial queryset and should return an iterable object that contains only the data in the requested page. This method accepts the following arguments: items : a queryset (or iterable) returned by the api function request : django http request object **params : kwargs that will contain all the arguments that decorated function received (to access pagination input get params[\"pagination\"] - it will be a validated instance of your Input class) Example: from ninja.pagination import paginate , PaginationBase from ninja import Schema class CustomPagination ( PaginationBase ): # only `skip` param, defaults to 5 per page class Input ( Schema ): skip : int def paginate_queryset ( self , items , request , ** params ): skip = params [ \"pagination\" ] . skip return items [ skip : skip + 5 ] @api . get ( '/users' , response = List [ UserSchema ]) @paginate ( CustomPagination ) def list_users ( request , ** kwargs ): return User . objects . all ()","title":"Creating Custom Pagination Class"},{"location":"tutorial/path-params/","text":"Path parameters You can declare path \"parameters\" with the same syntax used by Python format-strings (which luckily also matches the OpenAPI path parameters ): @api . get ( \"/items/ {item_id} \" ) def read_item ( request , item_id ): return { \"item_id\" : item_id } The value of the path parameter item_id will be passed to your function as the argument item_id . So, if you run this example and go to http://localhost:8000/api/items/foo , you will see this response: { \"item_id\" : \"foo\" } Path parameters with types You can declare the type of a path parameter in the function using standard Python type annotations: @api . get ( \"/items/ {item_id} \" ) def read_item ( request , item_id : int ): return { \"item_id\" : item_id } In this case, item_id is declared to be an int . This will give you editor and linter support for error checks, completion, etc. If you run this in your browser with http://localhost:8000/api/items/3 , you will see this response: { \"item_id\" : 3 } Tip Notice that the value your function received (and returned) is 3 , as a Python int - not a string \"3\" . So, with just that type declaration, Django Ninja gives you automatic request \"parsing\" and validation. Data validation On the other hand, if you go to the browser at http://localhost:8000/api/items/foo ( \"foo\" is not int) , you will see an HTTP error like this: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] } Django Path Converters You can use Django Path Converters to help parse the path: @api . get ( \"/items/{int:item_id}\" ) def read_item ( request , item_id ): return { \"item_id\" : item_id } In this case, item_id will be parsed as an int . If item_id is not a valid int , the url will not match. (e.g. if no other path matches, a 404 Not Found will be returned) Tip Notice that, since Django Ninja uses a default type of str for unannotated parameters, the value the function above received (and returned) is \"3\" , as a Python str - not an integer 3 , . To receive an int , simply declare item_id as an int type annotation in the function definition as normal: @api . get ( \"/items/{int:item_id}\" ) def read_item ( request , item_id : int ): return { \"item_id\" : item_id } Multiple parameters You can pass as many variables as you want into path , just remember to have unique names and don't forget to use the same names in the function arguments. @api . get ( \"/events/ {year} / {month} / {day} \" ) def events ( request , year : int , month : int , day : int ): return { \"date\" : [ year , month , day ]} Using Schema You can also use Schema to encapsulate path parameters that depend on each other (and validate them as a group): import datetime from ninja import Schema , Path class PathDate ( Schema ): year : int month : int day : int def value ( self ): return datetime . date ( self . year , self . month , self . day ) @api . get ( \"/events/ {year} / {month} / {day} \" ) def events ( request , date : PathDate = Path ( ... )): return { \"date\" : date . value ()} Note Notice that here we used a Path source hint to let Django Ninja know that this schema will be applied to path parameters. Documentation Now, when you open your browser at http://localhost:8000/api/docs , you will see the automatic, interactive, API documentation.","title":"Path parameters"},{"location":"tutorial/path-params/#path-parameters","text":"You can declare path \"parameters\" with the same syntax used by Python format-strings (which luckily also matches the OpenAPI path parameters ): @api . get ( \"/items/ {item_id} \" ) def read_item ( request , item_id ): return { \"item_id\" : item_id } The value of the path parameter item_id will be passed to your function as the argument item_id . So, if you run this example and go to http://localhost:8000/api/items/foo , you will see this response: { \"item_id\" : \"foo\" }","title":"Path parameters"},{"location":"tutorial/path-params/#path-parameters-with-types","text":"You can declare the type of a path parameter in the function using standard Python type annotations: @api . get ( \"/items/ {item_id} \" ) def read_item ( request , item_id : int ): return { \"item_id\" : item_id } In this case, item_id is declared to be an int . This will give you editor and linter support for error checks, completion, etc. If you run this in your browser with http://localhost:8000/api/items/3 , you will see this response: { \"item_id\" : 3 } Tip Notice that the value your function received (and returned) is 3 , as a Python int - not a string \"3\" . So, with just that type declaration, Django Ninja gives you automatic request \"parsing\" and validation.","title":"Path parameters with types"},{"location":"tutorial/path-params/#data-validation","text":"On the other hand, if you go to the browser at http://localhost:8000/api/items/foo ( \"foo\" is not int) , you will see an HTTP error like this: { \"detail\" : [ { \"loc\" : [ \"path\" , \"item_id\" ], \"msg\" : \"value is not a valid integer\" , \"type\" : \"type_error.integer\" } ] }","title":"Data validation"},{"location":"tutorial/path-params/#django-path-converters","text":"You can use Django Path Converters to help parse the path: @api . get ( \"/items/{int:item_id}\" ) def read_item ( request , item_id ): return { \"item_id\" : item_id } In this case, item_id will be parsed as an int . If item_id is not a valid int , the url will not match. (e.g. if no other path matches, a 404 Not Found will be returned) Tip Notice that, since Django Ninja uses a default type of str for unannotated parameters, the value the function above received (and returned) is \"3\" , as a Python str - not an integer 3 , . To receive an int , simply declare item_id as an int type annotation in the function definition as normal: @api . get ( \"/items/{int:item_id}\" ) def read_item ( request , item_id : int ): return { \"item_id\" : item_id }","title":"Django Path Converters"},{"location":"tutorial/path-params/#multiple-parameters","text":"You can pass as many variables as you want into path , just remember to have unique names and don't forget to use the same names in the function arguments. @api . get ( \"/events/ {year} / {month} / {day} \" ) def events ( request , year : int , month : int , day : int ): return { \"date\" : [ year , month , day ]}","title":"Multiple parameters"},{"location":"tutorial/path-params/#using-schema","text":"You can also use Schema to encapsulate path parameters that depend on each other (and validate them as a group): import datetime from ninja import Schema , Path class PathDate ( Schema ): year : int month : int day : int def value ( self ): return datetime . date ( self . year , self . month , self . day ) @api . get ( \"/events/ {year} / {month} / {day} \" ) def events ( request , date : PathDate = Path ( ... )): return { \"date\" : date . value ()} Note Notice that here we used a Path source hint to let Django Ninja know that this schema will be applied to path parameters.","title":"Using Schema"},{"location":"tutorial/path-params/#documentation","text":"Now, when you open your browser at http://localhost:8000/api/docs , you will see the automatic, interactive, API documentation.","title":"Documentation"},{"location":"tutorial/query-params/","text":"Query parameters When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters. weapons = [ \"Ninjato\" , \"Shuriken\" , \"Katana\" , \"Kama\" , \"Kunai\" , \"Naginata\" , \"Yari\" ] @api . get ( \"/weapons\" ) def list_weapons ( request , limit : int = 10 , offset : int = 0 ): return weapons [ offset : offset + limit ] To query this operation, you use a URL like: http://localhost:8000/api/weapons?offset=0&limit=10 By default, all GET parameters are strings, and when you annotate your function arguments with types, they are converted to that type and validated against it. The same benefits that apply to path parameters also apply to query parameters: Editor support (obviously) Data \"parsing\" Data validation Automatic documentation Note: if you do not annotate your arguments, they will be treated as str types: @api . get ( \"/weapons\" ) def list_weapons ( request , limit , offset ): # type(limit) == str # type(offset) == str Defaults As query parameters are not a fixed part of a path, they are optional and can have default values: @api . get ( \"/weapons\" ) def list_weapons ( request , limit : int = 10 , offset : int = 0 ): return weapons [ offset : offset + limit ] In the example above we set default values of offset=0 and limit=10 . So, going to the URL: http://localhost:8000/api/weapons would be the same as going to: http://localhost:8000/api/weapons?offset=0&limit=10 If you go to, for example: http://localhost:8000/api/weapons?offset=20 the parameter values in your function will be: offset=20 (because you set it in the URL) limit=10 (because that was the default value) Required and optional parameters You can declare required or optional GET parameters in the same way as declaring Python function arguments: weapons = [ \"Ninjato\" , \"Shuriken\" , \"Katana\" , \"Kama\" , \"Kunai\" , \"Naginata\" , \"Yari\" ] @api . get ( \"/weapons/search\" ) def search_weapons ( request , q : str , offset : int = 0 ): results = [ w for w in weapons if q in w . lower ()] print ( q , results ) return results [ offset : offset + 10 ] In this case, Django Ninja will always validate that you pass the q param in the GET, and the offset param is an optional integer. GET parameters type conversion Let's declare multiple type arguments: from datetime import date @api . get ( \"/example\" ) def example ( request , s : str = None , b : bool = None , d : date = None , i : int = None ): return [ s , b , d , i ] The str type is passed as is. For the bool type, all the following: http://localhost:8000/api/example?b=1 http://localhost:8000/api/example?b=True http://localhost:8000/api/example?b=true http://localhost:8000/api/example?b=on http://localhost:8000/api/example?b=yes or any other case variation (uppercase, first letter in uppercase, etc.), your function will see the parameter b with a bool value of True , otherwise as False . Date can be both date string and integer (unix timestamp): http://localhost:8000/api/example?d= 1577836800 # same as 2020-01-01 http://localhost:8000/api/example?d= 2020-01-01 Using Schema You can also use Schema to encapsulate GET parameters: import datetime from typing import List from pydantic import Field from ninja import Query , Schema class Filters ( Schema ): limit : int = 100 offset : int = None query : str = None category__in : List [ str ] = Field ( None , alias = \"categories\" ) @api . get ( \"/filter\" ) def events ( request , filters : Filters = Query ( ... )): return { \"filters\" : filters . dict ()}","title":"Query parameters"},{"location":"tutorial/query-params/#query-parameters","text":"When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters. weapons = [ \"Ninjato\" , \"Shuriken\" , \"Katana\" , \"Kama\" , \"Kunai\" , \"Naginata\" , \"Yari\" ] @api . get ( \"/weapons\" ) def list_weapons ( request , limit : int = 10 , offset : int = 0 ): return weapons [ offset : offset + limit ] To query this operation, you use a URL like: http://localhost:8000/api/weapons?offset=0&limit=10 By default, all GET parameters are strings, and when you annotate your function arguments with types, they are converted to that type and validated against it. The same benefits that apply to path parameters also apply to query parameters: Editor support (obviously) Data \"parsing\" Data validation Automatic documentation Note: if you do not annotate your arguments, they will be treated as str types: @api . get ( \"/weapons\" ) def list_weapons ( request , limit , offset ): # type(limit) == str # type(offset) == str","title":"Query parameters"},{"location":"tutorial/query-params/#defaults","text":"As query parameters are not a fixed part of a path, they are optional and can have default values: @api . get ( \"/weapons\" ) def list_weapons ( request , limit : int = 10 , offset : int = 0 ): return weapons [ offset : offset + limit ] In the example above we set default values of offset=0 and limit=10 . So, going to the URL: http://localhost:8000/api/weapons would be the same as going to: http://localhost:8000/api/weapons?offset=0&limit=10 If you go to, for example: http://localhost:8000/api/weapons?offset=20 the parameter values in your function will be: offset=20 (because you set it in the URL) limit=10 (because that was the default value)","title":"Defaults"},{"location":"tutorial/query-params/#required-and-optional-parameters","text":"You can declare required or optional GET parameters in the same way as declaring Python function arguments: weapons = [ \"Ninjato\" , \"Shuriken\" , \"Katana\" , \"Kama\" , \"Kunai\" , \"Naginata\" , \"Yari\" ] @api . get ( \"/weapons/search\" ) def search_weapons ( request , q : str , offset : int = 0 ): results = [ w for w in weapons if q in w . lower ()] print ( q , results ) return results [ offset : offset + 10 ] In this case, Django Ninja will always validate that you pass the q param in the GET, and the offset param is an optional integer.","title":"Required and optional parameters"},{"location":"tutorial/query-params/#get-parameters-type-conversion","text":"Let's declare multiple type arguments: from datetime import date @api . get ( \"/example\" ) def example ( request , s : str = None , b : bool = None , d : date = None , i : int = None ): return [ s , b , d , i ] The str type is passed as is. For the bool type, all the following: http://localhost:8000/api/example?b=1 http://localhost:8000/api/example?b=True http://localhost:8000/api/example?b=true http://localhost:8000/api/example?b=on http://localhost:8000/api/example?b=yes or any other case variation (uppercase, first letter in uppercase, etc.), your function will see the parameter b with a bool value of True , otherwise as False . Date can be both date string and integer (unix timestamp): http://localhost:8000/api/example?d= 1577836800 # same as 2020-01-01 http://localhost:8000/api/example?d= 2020-01-01","title":"GET parameters type conversion"},{"location":"tutorial/query-params/#using-schema","text":"You can also use Schema to encapsulate GET parameters: import datetime from typing import List from pydantic import Field from ninja import Query , Schema class Filters ( Schema ): limit : int = 100 offset : int = None query : str = None category__in : List [ str ] = Field ( None , alias = \"categories\" ) @api . get ( \"/filter\" ) def events ( request , filters : Filters = Query ( ... )): return { \"filters\" : filters . dict ()}","title":"Using Schema"},{"location":"tutorial/request-parsers/","text":"Request parsers In most cases, the default content type for REST API's is JSON, but in case you need to work with other content types (like YAML, XML, CSV) or use faster JSON parsers, Django Ninja provides a parser configuration. api = NinjaAPI ( parser = MyYamlParser ()) To create your own parser, you need to extend the ninja.parser.Parser class, and override the parse_body method. Example YAML Parser Let's create our custom YAML parser: import yaml from typing import List from ninja import NinjaAPI from ninja.parser import Parser class MyYamlParser ( Parser ): def parse_body ( self , request ): return yaml . safe_load ( request . body ) api = NinjaAPI ( parser = MyYamlParser ()) class Payload ( Schema ): ints : List [ int ] string : str f : float @api . post ( '/yaml' ) def operation ( request , payload : Payload ): return payload . dict () If you now send YAML like this as the request body: ints : - 0 - 1 string : hello f : 3.14 it will be correctly parsed, and you should have JSON output like this: { \"ints\" : [ 0 , 1 ], \"string\" : \"hello\" , \"f\" : 3.14 } Example ORJSON Parser orjson is a fast, accurate JSON library for Python. It benchmarks as the fastest Python library for JSON and is more accurate than the standard json library or other third-party libraries. pip install orjson Parser code: import orjson from ninja import NinjaAPI from ninja.parser import Parser class ORJSONParser ( Parser ): def parse_body ( self , request ): return orjson . loads ( request . body ) api = NinjaAPI ( parser = ORJSONParser ())","title":"Request parsers"},{"location":"tutorial/request-parsers/#request-parsers","text":"In most cases, the default content type for REST API's is JSON, but in case you need to work with other content types (like YAML, XML, CSV) or use faster JSON parsers, Django Ninja provides a parser configuration. api = NinjaAPI ( parser = MyYamlParser ()) To create your own parser, you need to extend the ninja.parser.Parser class, and override the parse_body method.","title":"Request parsers"},{"location":"tutorial/request-parsers/#example-yaml-parser","text":"Let's create our custom YAML parser: import yaml from typing import List from ninja import NinjaAPI from ninja.parser import Parser class MyYamlParser ( Parser ): def parse_body ( self , request ): return yaml . safe_load ( request . body ) api = NinjaAPI ( parser = MyYamlParser ()) class Payload ( Schema ): ints : List [ int ] string : str f : float @api . post ( '/yaml' ) def operation ( request , payload : Payload ): return payload . dict () If you now send YAML like this as the request body: ints : - 0 - 1 string : hello f : 3.14 it will be correctly parsed, and you should have JSON output like this: { \"ints\" : [ 0 , 1 ], \"string\" : \"hello\" , \"f\" : 3.14 }","title":"Example YAML Parser"},{"location":"tutorial/request-parsers/#example-orjson-parser","text":"orjson is a fast, accurate JSON library for Python. It benchmarks as the fastest Python library for JSON and is more accurate than the standard json library or other third-party libraries. pip install orjson Parser code: import orjson from ninja import NinjaAPI from ninja.parser import Parser class ORJSONParser ( Parser ): def parse_body ( self , request ): return orjson . loads ( request . body ) api = NinjaAPI ( parser = ORJSONParser ())","title":"Example ORJSON Parser"},{"location":"tutorial/response-renderers/","text":"Response renderers The most common response type for a REST API is usually JSON. Django Ninja also has support for defining your own custom renderers, which gives you the flexibility to design your own media types. Create a renderer To create your own renderer, you need to inherit ninja.renderers.BaseRenderer and override the render method. Then you can pass an instance of your class to NinjaAPI as the renderer argument: from ninja import NinjaAPI from ninja.renderers import BaseRenderer class MyRenderer ( BaseRenderer ): media_type = \"text/plain\" def render ( self , request , data , * , response_status ): return ... # your serialization here api = NinjaAPI ( renderer = MyRenderer ()) The render method takes the following arguments: - request -> HttpRequest object - data -> object that needs to be serialized - response_status as an int -> the HTTP status code that will be returned to the client You need also define the media_type attribute on the class to set the content-type header for the response. ORJSON renderer example: orjson is a fast, accurate JSON library for Python. It benchmarks as the fastest Python library for JSON and is more accurate than the standard json library or other third-party libraries. It also serializes dataclass, datetime, numpy, and UUID instances natively. Here's an example renderer class that uses orjson : import orjson from ninja import NinjaAPI from ninja.renderers import BaseRenderer class ORJSONRenderer ( BaseRenderer ): media_type = \"application/json\" def render ( self , request , data , * , response_status ): return orjson . dumps ( data ) api = NinjaAPI ( renderer = ORJSONRenderer ()) XML renderer example: This is how you create a renderer that outputs all responses as XML: from io import StringIO from django.utils.encoding import force_str from django.utils.xmlutils import SimplerXMLGenerator from ninja import NinjaAPI from ninja.renderers import BaseRenderer class XMLRenderer ( BaseRenderer ): media_type = \"text/xml\" def render ( self , request , data , * , response_status ): stream = StringIO () xml = SimplerXMLGenerator ( stream , \"utf-8\" ) xml . startDocument () xml . startElement ( \"data\" , {}) self . _to_xml ( xml , data ) xml . endElement ( \"data\" ) xml . endDocument () return stream . getvalue () def _to_xml ( self , xml , data ): if isinstance ( data , ( list , tuple )): for item in data : xml . startElement ( \"item\" , {}) self . _to_xml ( xml , item ) xml . endElement ( \"item\" ) elif isinstance ( data , dict ): for key , value in data . items (): xml . startElement ( key , {}) self . _to_xml ( xml , value ) xml . endElement ( key ) elif data is None : # Don't output any value pass else : xml . characters ( force_str ( data )) api = NinjaAPI ( renderer = XMLRenderer ()) (Copyright note: this code is basically copied from DRF-xml )","title":"Response renderers"},{"location":"tutorial/response-renderers/#response-renderers","text":"The most common response type for a REST API is usually JSON. Django Ninja also has support for defining your own custom renderers, which gives you the flexibility to design your own media types.","title":"Response renderers"},{"location":"tutorial/response-renderers/#create-a-renderer","text":"To create your own renderer, you need to inherit ninja.renderers.BaseRenderer and override the render method. Then you can pass an instance of your class to NinjaAPI as the renderer argument: from ninja import NinjaAPI from ninja.renderers import BaseRenderer class MyRenderer ( BaseRenderer ): media_type = \"text/plain\" def render ( self , request , data , * , response_status ): return ... # your serialization here api = NinjaAPI ( renderer = MyRenderer ()) The render method takes the following arguments: - request -> HttpRequest object - data -> object that needs to be serialized - response_status as an int -> the HTTP status code that will be returned to the client You need also define the media_type attribute on the class to set the content-type header for the response.","title":"Create a renderer"},{"location":"tutorial/response-renderers/#orjson-renderer-example","text":"orjson is a fast, accurate JSON library for Python. It benchmarks as the fastest Python library for JSON and is more accurate than the standard json library or other third-party libraries. It also serializes dataclass, datetime, numpy, and UUID instances natively. Here's an example renderer class that uses orjson : import orjson from ninja import NinjaAPI from ninja.renderers import BaseRenderer class ORJSONRenderer ( BaseRenderer ): media_type = \"application/json\" def render ( self , request , data , * , response_status ): return orjson . dumps ( data ) api = NinjaAPI ( renderer = ORJSONRenderer ())","title":"ORJSON renderer example:"},{"location":"tutorial/response-renderers/#xml-renderer-example","text":"This is how you create a renderer that outputs all responses as XML: from io import StringIO from django.utils.encoding import force_str from django.utils.xmlutils import SimplerXMLGenerator from ninja import NinjaAPI from ninja.renderers import BaseRenderer class XMLRenderer ( BaseRenderer ): media_type = \"text/xml\" def render ( self , request , data , * , response_status ): stream = StringIO () xml = SimplerXMLGenerator ( stream , \"utf-8\" ) xml . startDocument () xml . startElement ( \"data\" , {}) self . _to_xml ( xml , data ) xml . endElement ( \"data\" ) xml . endDocument () return stream . getvalue () def _to_xml ( self , xml , data ): if isinstance ( data , ( list , tuple )): for item in data : xml . startElement ( \"item\" , {}) self . _to_xml ( xml , item ) xml . endElement ( \"item\" ) elif isinstance ( data , dict ): for key , value in data . items (): xml . startElement ( key , {}) self . _to_xml ( xml , value ) xml . endElement ( key ) elif data is None : # Don't output any value pass else : xml . characters ( force_str ( data )) api = NinjaAPI ( renderer = XMLRenderer ()) (Copyright note: this code is basically copied from DRF-xml )","title":"XML renderer example:"},{"location":"tutorial/response-schema/","text":"Response Schema Django Ninja allows you to define the schema of your responses both for validation and documentation purposes. Imagine you need to create an API operation that creates a user. The input parameter would be username+password , but output of this operation should be id+username ( without the password). Let's create the input schema: from ninja import Schema class UserIn ( Schema ): username : str password : str @api . post ( \"/users/\" ) def create_user ( request , data : UserIn ): user = User ( username = data . username ) # User is django auth.User user . set_password ( data . password ) user . save () # ... return ? Now let's define the output schema, and pass it as a response argument to the @api.post decorator: from ninja import Schema class UserIn ( Schema ): username : str password : str class UserOut ( Schema ): id : int username : str @api . post ( \"/users/\" , response = UserOut ) def create_user ( request , data : UserIn ): user = User ( username = data . username ) user . set_password ( data . password ) user . save () return user Django Ninja will use this response schema to: convert the output data to declared schema validate the data add an OpenAPI schema definition it will be used by the automatic documentation systems and, most importantly, it will limit the output data only to the fields only defined in the schema. Nested objects There is also often a need to return responses with some nested/child objects. Imagine we have a Task Django model with a User ForeignKey: from django.db import models class Task ( models . Model ): title = models . CharField ( max_length = 200 ) is_completed = models . BooleanField ( default = False ) owner = models . ForeignKey ( \"auth.User\" , null = True , blank = True ) Now let's output all tasks, and for each task, output some fields about the user. from typing import List from ninja import Schema class UserSchema ( Schema ): id : int first_name : str last_name : str class TaskSchema ( Schema ): id : int title : str is_completed : bool owner : UserSchema = None # ! None - to mark it as optional @api . get ( \"/tasks\" , response = List [ TaskSchema ]) def tasks ( request ): queryset = Task . objects . all () return list ( queryset ) If you execute this operation, you should get a response like this: [ { \"id\" : 1 , \"title\" : \"Task 1\" , \"is_completed\" : false , \"owner\" : { \"id\" : 1 , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , } }, { \"id\" : 2 , \"title\" : \"Task 2\" , \"is_completed\" : false , \"owner\" : null }, ] Returning querysets In the previous example we specifically converted a queryset into a list (and executed the SQL query during evaluation). You can avoid that and return a queryset as a result, and it will be automatically evaluated to List: @api . get ( \"/tasks\" , response = List [ TaskSchema ]) def tasks ( request ): return Task . objects . all () Note about async mode If your operation is async async-support , this example will not work. @api . get ( \"/tasks\" , response = List [ TaskSchema ]) async def tasks ( request ): return Task . objects . all () FileField and ImageField Django Ninja by default converts files and images (declared with FileField or ImageField ) to string URL's. An example: class Picture ( models . Model ): title = models . CharField ( max_length = 100 ) image = models . ImageField ( upload_to = 'images' ) If you need to output to response image field, declare a schema for it as follows: class PictureSchema ( Schema ): title : str image : str Once you output this to a response, the URL will be automatically generated for each object: { \"title\" : \"Zebra\" , \"image\" : \"/static/images/zebra.jpg\" } Multiple Response Schemas Sometimes you need to define more than response schemas. In case of authentication, for example, you can return: 200 successful -> token 401 -> Unauthorized 402 -> Payment required etc.. In fact, the OpenAPI specification allows you to pass multiple response schemas. You can pass to a response argument a dictionary where: key is a response code value is a schema for that code Also, when you return the result - you have to also pass a status code to tell Django Ninja which schema should be used for validation and serialization. An example: class Token ( Schema ): token : str expires : date class Message ( Schema ): message : str @api . post ( '/login' , response = { 200 : Token , 401 : Message , 402 : Message }) def login ( request , payload : Auth ): if auth_not_valid : return 401 , { 'message' : 'Unauthorized' } if negative_balance : return 402 , { 'message' : 'Insufficient balance amount. Please proceed to a payment page.' } return 200 , { 'token' : xxx , ... } Multiple response codes In the previous example you saw that we basically repeated the Message schema twice: ...401: Message, 402: Message} To avoid this duplication you can use multiple response codes for a schema: ... from ninja.responses import codes_4xx @api . post ( '/login' , response = { 200 : Token , codes_4xx : Message }) def login ( request , payload : Auth ): if auth_not_valid : return 401 , { 'message' : 'Unauthorized' } if negative_balance : return 402 , { 'message' : 'Insufficient balance amount. Please proceed to a payment page.' } return 200 , { 'token' : xxx , ... } Django Ninja comes with the following HTTP codes: from ninja.responses import codes_1xx from ninja.responses import codes_2xx from ninja.responses import codes_3xx from ninja.responses import codes_4xx from ninja.responses import codes_5xx You can also create your own range using a frozenset : my_codes = frozenset ({ 416 , 418 , 425 , 429 , 451 }) ... @api . post ( '/login' , response = { 200 : Token , my_codes : Message }) ... Empty responses Some responses, such as 204 No Content , have no body. To indicate the response body is empty mark response argument with None instead of Schema: @api . post ( \"/no_content\" , response = { 204 : None }) def no_content ( request ): return 204 , None Self-referencing schemes Sometimes you need to create a schema that has reference to itself, or tree-structure objects. To do that you need: set a type of your schema in quotes use update_forward_refs method to apply self referencing types class Organization ( Schema ): title : str part_of : 'Organization' = None #!! note the type in quotes here !! Organization . update_forward_refs () # !!! this is important @api . get ( '/organizations' , response = List [ Organization ]) def list_organizations ( request ): ... Self-referencing schemes from create_schema() To be able to use the method update_forward_refs() from a schema generated via create_schema() , the \"name\" of the class needs to be in our namespace. In this case it is very important to pass the name parameter to create_schema() UserSchema = create_schema ( User , name = 'UserSchema' , # !!! this is important for update_forward_refs() fields = [ 'id' , 'username' ] custom_fields = [ ( 'manager' , 'UserSchema' , None ), ] ) UserSchema . update_forward_refs ()","title":"Response Schema"},{"location":"tutorial/response-schema/#response-schema","text":"Django Ninja allows you to define the schema of your responses both for validation and documentation purposes. Imagine you need to create an API operation that creates a user. The input parameter would be username+password , but output of this operation should be id+username ( without the password). Let's create the input schema: from ninja import Schema class UserIn ( Schema ): username : str password : str @api . post ( \"/users/\" ) def create_user ( request , data : UserIn ): user = User ( username = data . username ) # User is django auth.User user . set_password ( data . password ) user . save () # ... return ? Now let's define the output schema, and pass it as a response argument to the @api.post decorator: from ninja import Schema class UserIn ( Schema ): username : str password : str class UserOut ( Schema ): id : int username : str @api . post ( \"/users/\" , response = UserOut ) def create_user ( request , data : UserIn ): user = User ( username = data . username ) user . set_password ( data . password ) user . save () return user Django Ninja will use this response schema to: convert the output data to declared schema validate the data add an OpenAPI schema definition it will be used by the automatic documentation systems and, most importantly, it will limit the output data only to the fields only defined in the schema.","title":"Response Schema"},{"location":"tutorial/response-schema/#nested-objects","text":"There is also often a need to return responses with some nested/child objects. Imagine we have a Task Django model with a User ForeignKey: from django.db import models class Task ( models . Model ): title = models . CharField ( max_length = 200 ) is_completed = models . BooleanField ( default = False ) owner = models . ForeignKey ( \"auth.User\" , null = True , blank = True ) Now let's output all tasks, and for each task, output some fields about the user. from typing import List from ninja import Schema class UserSchema ( Schema ): id : int first_name : str last_name : str class TaskSchema ( Schema ): id : int title : str is_completed : bool owner : UserSchema = None # ! None - to mark it as optional @api . get ( \"/tasks\" , response = List [ TaskSchema ]) def tasks ( request ): queryset = Task . objects . all () return list ( queryset ) If you execute this operation, you should get a response like this: [ { \"id\" : 1 , \"title\" : \"Task 1\" , \"is_completed\" : false , \"owner\" : { \"id\" : 1 , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , } }, { \"id\" : 2 , \"title\" : \"Task 2\" , \"is_completed\" : false , \"owner\" : null }, ]","title":"Nested objects"},{"location":"tutorial/response-schema/#returning-querysets","text":"In the previous example we specifically converted a queryset into a list (and executed the SQL query during evaluation). You can avoid that and return a queryset as a result, and it will be automatically evaluated to List: @api . get ( \"/tasks\" , response = List [ TaskSchema ]) def tasks ( request ): return Task . objects . all ()","title":"Returning querysets"},{"location":"tutorial/response-schema/#note-about-async-mode","text":"If your operation is async async-support , this example will not work. @api . get ( \"/tasks\" , response = List [ TaskSchema ]) async def tasks ( request ): return Task . objects . all ()","title":"Note about async mode"},{"location":"tutorial/response-schema/#filefield-and-imagefield","text":"Django Ninja by default converts files and images (declared with FileField or ImageField ) to string URL's. An example: class Picture ( models . Model ): title = models . CharField ( max_length = 100 ) image = models . ImageField ( upload_to = 'images' ) If you need to output to response image field, declare a schema for it as follows: class PictureSchema ( Schema ): title : str image : str Once you output this to a response, the URL will be automatically generated for each object: { \"title\" : \"Zebra\" , \"image\" : \"/static/images/zebra.jpg\" }","title":"FileField and ImageField"},{"location":"tutorial/response-schema/#multiple-response-schemas","text":"Sometimes you need to define more than response schemas. In case of authentication, for example, you can return: 200 successful -> token 401 -> Unauthorized 402 -> Payment required etc.. In fact, the OpenAPI specification allows you to pass multiple response schemas. You can pass to a response argument a dictionary where: key is a response code value is a schema for that code Also, when you return the result - you have to also pass a status code to tell Django Ninja which schema should be used for validation and serialization. An example: class Token ( Schema ): token : str expires : date class Message ( Schema ): message : str @api . post ( '/login' , response = { 200 : Token , 401 : Message , 402 : Message }) def login ( request , payload : Auth ): if auth_not_valid : return 401 , { 'message' : 'Unauthorized' } if negative_balance : return 402 , { 'message' : 'Insufficient balance amount. Please proceed to a payment page.' } return 200 , { 'token' : xxx , ... }","title":"Multiple Response Schemas"},{"location":"tutorial/response-schema/#multiple-response-codes","text":"In the previous example you saw that we basically repeated the Message schema twice: ...401: Message, 402: Message} To avoid this duplication you can use multiple response codes for a schema: ... from ninja.responses import codes_4xx @api . post ( '/login' , response = { 200 : Token , codes_4xx : Message }) def login ( request , payload : Auth ): if auth_not_valid : return 401 , { 'message' : 'Unauthorized' } if negative_balance : return 402 , { 'message' : 'Insufficient balance amount. Please proceed to a payment page.' } return 200 , { 'token' : xxx , ... } Django Ninja comes with the following HTTP codes: from ninja.responses import codes_1xx from ninja.responses import codes_2xx from ninja.responses import codes_3xx from ninja.responses import codes_4xx from ninja.responses import codes_5xx You can also create your own range using a frozenset : my_codes = frozenset ({ 416 , 418 , 425 , 429 , 451 }) ... @api . post ( '/login' , response = { 200 : Token , my_codes : Message }) ...","title":"Multiple response codes"},{"location":"tutorial/response-schema/#empty-responses","text":"Some responses, such as 204 No Content , have no body. To indicate the response body is empty mark response argument with None instead of Schema: @api . post ( \"/no_content\" , response = { 204 : None }) def no_content ( request ): return 204 , None","title":"Empty responses"},{"location":"tutorial/response-schema/#self-referencing-schemes","text":"Sometimes you need to create a schema that has reference to itself, or tree-structure objects. To do that you need: set a type of your schema in quotes use update_forward_refs method to apply self referencing types class Organization ( Schema ): title : str part_of : 'Organization' = None #!! note the type in quotes here !! Organization . update_forward_refs () # !!! this is important @api . get ( '/organizations' , response = List [ Organization ]) def list_organizations ( request ): ...","title":"Self-referencing schemes"},{"location":"tutorial/response-schema/#self-referencing-schemes-from-create_schema","text":"To be able to use the method update_forward_refs() from a schema generated via create_schema() , the \"name\" of the class needs to be in our namespace. In this case it is very important to pass the name parameter to create_schema() UserSchema = create_schema ( User , name = 'UserSchema' , # !!! this is important for update_forward_refs() fields = [ 'id' , 'username' ] custom_fields = [ ( 'manager' , 'UserSchema' , None ), ] ) UserSchema . update_forward_refs ()","title":"Self-referencing schemes from create_schema()"},{"location":"tutorial/routers/","text":"Routers Real world applications can almost never fit all logic into a single file. Django Ninja comes with an easy way to split your API into multiple modules using Routers. Let's say you have a Django project with a structure like this: \u251c\u2500\u2500 myproject \u2502 \u2514\u2500\u2500 settings.py \u251c\u2500\u2500 events/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 news/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 blogs/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 models.py \u2514\u2500\u2500 manage.py To add API's to each of the Django applications, create an api.py module in each app: \u251c\u2500\u2500 myproject \u2502 \u2514\u2500\u2500 settings.py \u251c\u2500\u2500 events/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 api.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 news/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 api.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 blogs/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 api.py \u2502 \u2514\u2500\u2500 models.py \u2514\u2500\u2500 manage.py Now let's add a few operations to events/api.py . The trick is that instead of using the NinjaAPI class, you use the Router class: from ninja import Router from .models import Event router = Router () @router . get ( '/' ) def list_events ( request ): return [ { \"id\" : e . id , \"title\" : e . title } for e in Event . objects . all () ] @router . get ( '/ {event_id} ' ) def event_details ( request , event_id : int ): event = Event . objects . get ( id = event_id ) return { \"title\" : event . title , \"details\" : event . details } Then do the same for the news app with news/api.py : from ninja import Router from .models import News router = Router () @router . get ( '/' ) def list_news ( request ): ... @router . get ( '/ {news_id} ' ) def news_details ( request , news_id : int ): ... and then also blogs/api.py . Finally, let's group them together. In your top level project folder (next to urls.py ), create another api.py file with the main NinjaAPI instance: \u251c\u2500\u2500 myproject \u2502 \u251c\u2500\u2500 api.py \u2502 \u2514\u2500\u2500 settings.py \u251c\u2500\u2500 events/ \u2502 ... \u251c\u2500\u2500 news/ \u2502 ... \u251c\u2500\u2500 blogs/ \u2502 ... It should look like this: from ninja import NinjaAPI api = NinjaAPI () Now we import all the routers from the various apps, and include them into the main API instance: from ninja import NinjaAPI from events.api import router as events_router from news.api import router as news_router from blogs.api import router as blogs_router api = NinjaAPI () api . add_router ( \"/events/\" , events_router ) api . add_router ( \"/news/\" , news_router ) api . add_router ( \"/blogs/\" , blogs_router ) Now, include api to your urls as usual and open your browser at /api/docs , and you should see all your routers combined into a single API: Router authentication Use auth argument to apply authenticator to all operations declared by router: api . add_router ( \"/events/\" , events_router , auth = BasicAuth ()) or using router constructor router = Router ( auth = BasicAuth ()) Router tags You can use tags argument to apply tags to all operations declared by router: api . add_router ( \"/events/\" , events_router , tags = [ \"events\" ]) or using router constructor router = Router ( tags = [ \"events\" ]) Nested routers There are also times when you need to split your logic up even more. Django Ninja makes it possible to include a router into another router as many times as you like, and finally include the top level router into the main api instance. Basically, what that means is that you have add_router both on the api instance and on the router instance: from django.contrib import admin from django.urls import path from ninja import NinjaAPI , Router api = NinjaAPI () first_router = Router () second_router = Router () third_router = Router () @api . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } @first_router . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } @second_router . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } @third_router . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } second_router . add_router ( \"l3\" , third_router ) first_router . add_router ( \"l2\" , second_router ) api . add_router ( \"l1\" , first_router ) urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ] Now you have the following endpoints: /api/add /api/l1/add /api/l1/l2/add /api/l1/l2/l3/add Great! Now go have a look at the automatically generated docs:","title":"Routers"},{"location":"tutorial/routers/#routers","text":"Real world applications can almost never fit all logic into a single file. Django Ninja comes with an easy way to split your API into multiple modules using Routers. Let's say you have a Django project with a structure like this: \u251c\u2500\u2500 myproject \u2502 \u2514\u2500\u2500 settings.py \u251c\u2500\u2500 events/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 news/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 blogs/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 models.py \u2514\u2500\u2500 manage.py To add API's to each of the Django applications, create an api.py module in each app: \u251c\u2500\u2500 myproject \u2502 \u2514\u2500\u2500 settings.py \u251c\u2500\u2500 events/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 api.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 news/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 api.py \u2502 \u2514\u2500\u2500 models.py \u251c\u2500\u2500 blogs/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 api.py \u2502 \u2514\u2500\u2500 models.py \u2514\u2500\u2500 manage.py Now let's add a few operations to events/api.py . The trick is that instead of using the NinjaAPI class, you use the Router class: from ninja import Router from .models import Event router = Router () @router . get ( '/' ) def list_events ( request ): return [ { \"id\" : e . id , \"title\" : e . title } for e in Event . objects . all () ] @router . get ( '/ {event_id} ' ) def event_details ( request , event_id : int ): event = Event . objects . get ( id = event_id ) return { \"title\" : event . title , \"details\" : event . details } Then do the same for the news app with news/api.py : from ninja import Router from .models import News router = Router () @router . get ( '/' ) def list_news ( request ): ... @router . get ( '/ {news_id} ' ) def news_details ( request , news_id : int ): ... and then also blogs/api.py . Finally, let's group them together. In your top level project folder (next to urls.py ), create another api.py file with the main NinjaAPI instance: \u251c\u2500\u2500 myproject \u2502 \u251c\u2500\u2500 api.py \u2502 \u2514\u2500\u2500 settings.py \u251c\u2500\u2500 events/ \u2502 ... \u251c\u2500\u2500 news/ \u2502 ... \u251c\u2500\u2500 blogs/ \u2502 ... It should look like this: from ninja import NinjaAPI api = NinjaAPI () Now we import all the routers from the various apps, and include them into the main API instance: from ninja import NinjaAPI from events.api import router as events_router from news.api import router as news_router from blogs.api import router as blogs_router api = NinjaAPI () api . add_router ( \"/events/\" , events_router ) api . add_router ( \"/news/\" , news_router ) api . add_router ( \"/blogs/\" , blogs_router ) Now, include api to your urls as usual and open your browser at /api/docs , and you should see all your routers combined into a single API:","title":"Routers"},{"location":"tutorial/routers/#router-authentication","text":"Use auth argument to apply authenticator to all operations declared by router: api . add_router ( \"/events/\" , events_router , auth = BasicAuth ()) or using router constructor router = Router ( auth = BasicAuth ())","title":"Router authentication"},{"location":"tutorial/routers/#router-tags","text":"You can use tags argument to apply tags to all operations declared by router: api . add_router ( \"/events/\" , events_router , tags = [ \"events\" ]) or using router constructor router = Router ( tags = [ \"events\" ])","title":"Router tags"},{"location":"tutorial/routers/#nested-routers","text":"There are also times when you need to split your logic up even more. Django Ninja makes it possible to include a router into another router as many times as you like, and finally include the top level router into the main api instance. Basically, what that means is that you have add_router both on the api instance and on the router instance: from django.contrib import admin from django.urls import path from ninja import NinjaAPI , Router api = NinjaAPI () first_router = Router () second_router = Router () third_router = Router () @api . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } @first_router . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } @second_router . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } @third_router . get ( \"/add\" ) def add ( request , a : int , b : int ): return { \"result\" : a + b } second_router . add_router ( \"l3\" , third_router ) first_router . add_router ( \"l2\" , second_router ) api . add_router ( \"l1\" , first_router ) urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ] Now you have the following endpoints: /api/add /api/l1/add /api/l1/l2/add /api/l1/l2/l3/add Great! Now go have a look at the automatically generated docs:","title":"Nested routers"},{"location":"tutorial/urls/","text":"Reverse Resolution of URLS A reverse URL name is generated for each method in a Django Ninja Schema (or Router ). How URLs are generated The URLs are all contained within a namespace, which defaults to \"api-1.0.0\" , and each URL name matches the function it is decorated. For example: api = NinjaAPI () @api . get ( \"/\" ) def index ( request ): ... index_url = reverse_lazy ( \"api-1.0.0:index\" ) Changing the URL name Rather than using the default URL name, you can specficy it explicitly as a property on the method decorator. @api . get ( \"/users\" , url_name = \"user_list\" ) def users ( request ): ... users_url = reverse_lazy ( \"api-1.0.0:user_list\" ) Customizing the namespace The default URL namespace is built by prepending the Schema's version with \"api-\" , however you can explicitly specify the namespace by overriding the urls_namespace attribute of the NinjaAPI Schema class. api = NinjaAPI ( auth = token_auth , version = '2' ) api_private = NinjaAPI ( auth = session_auth , urls_namespace = 'private_api' ) api_users_url = reverse_lazy ( \"api-2:users\" ) private_api_admins_url = reverse_lazy ( \"private_api:admins\" )","title":"Reverse Resolution of URLS"},{"location":"tutorial/urls/#reverse-resolution-of-urls","text":"A reverse URL name is generated for each method in a Django Ninja Schema (or Router ).","title":"Reverse Resolution of URLS"},{"location":"tutorial/urls/#how-urls-are-generated","text":"The URLs are all contained within a namespace, which defaults to \"api-1.0.0\" , and each URL name matches the function it is decorated. For example: api = NinjaAPI () @api . get ( \"/\" ) def index ( request ): ... index_url = reverse_lazy ( \"api-1.0.0:index\" )","title":"How URLs are generated"},{"location":"tutorial/urls/#changing-the-url-name","text":"Rather than using the default URL name, you can specficy it explicitly as a property on the method decorator. @api . get ( \"/users\" , url_name = \"user_list\" ) def users ( request ): ... users_url = reverse_lazy ( \"api-1.0.0:user_list\" )","title":"Changing the URL name"},{"location":"tutorial/urls/#customizing-the-namespace","text":"The default URL namespace is built by prepending the Schema's version with \"api-\" , however you can explicitly specify the namespace by overriding the urls_namespace attribute of the NinjaAPI Schema class. api = NinjaAPI ( auth = token_auth , version = '2' ) api_private = NinjaAPI ( auth = session_auth , urls_namespace = 'private_api' ) api_users_url = reverse_lazy ( \"api-2:users\" ) private_api_admins_url = reverse_lazy ( \"private_api:admins\" )","title":"Customizing the namespace"},{"location":"tutorial/versioning/","text":"Versioning Different API version numbers With Django Ninja it's easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja import NinjaAPI api = NinjaAPI ( version = '1.0.0' ) @api . get ( '/hello' ) def hello ( request ): return { 'message' : 'Hello from V1' } api_ v2 .py: from ninja import NinjaAPI api = NinjaAPI ( version = '2.0.0' ) @api . get ( '/hello' ) def hello ( request ): return { 'message' : 'Hello from V2' } and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs Different business logic In the same way, you can define a different API for different components or areas: ... api = NinjaAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaAPI instances, you need to define different version s or different urls_namespace s.","title":"Versioning"},{"location":"tutorial/versioning/#versioning","text":"","title":"Versioning"},{"location":"tutorial/versioning/#different-api-version-numbers","text":"With Django Ninja it's easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja import NinjaAPI api = NinjaAPI ( version = '1.0.0' ) @api . get ( '/hello' ) def hello ( request ): return { 'message' : 'Hello from V1' } api_ v2 .py: from ninja import NinjaAPI api = NinjaAPI ( version = '2.0.0' ) @api . get ( '/hello' ) def hello ( request ): return { 'message' : 'Hello from V2' } and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs","title":"Different API version numbers"},{"location":"tutorial/versioning/#different-business-logic","text":"In the same way, you can define a different API for different components or areas: ... api = NinjaAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaAPI instances, you need to define different version s or different urls_namespace s.","title":"Different business logic"}]}